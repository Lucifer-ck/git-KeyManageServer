// **********************************************************************
// This file was generated by a TARS parser!
// TARS version 3.0.15.
// **********************************************************************

#ifndef __KEYMANAGE_H_
#define __KEYMANAGE_H_

#include <map>
#include <string>
#include <vector>
#include "tup/Tars.h"
#include "tup/TarsJson.h"
using namespace std;
#include "servant/ServantProxy.h"
#include "servant/Servant.h"
#include "promise/promise.h"
#include "servant/Application.h"


namespace Mitsurugi
{
    struct PhSessionHandle : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "Mitsurugi.PhSessionHandle";
        }
        static string MD5()
        {
            return "7b010a6336d210a506b1eb4bf4c1e014";
        }
        PhSessionHandle()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            phSessionHandle = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(phSessionHandle, 0);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(phSessionHandle, 0, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["phSessionHandle"] = tars::JsonOutput::writeJson(phSessionHandle);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(phSessionHandle,pObj->value["phSessionHandle"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(phSessionHandle,"phSessionHandle");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(phSessionHandle, false);
            return _os;
        }
    public:
        tars::Int32 phSessionHandle;
    };
    inline bool operator==(const PhSessionHandle&l, const PhSessionHandle&r)
    {
        return l.phSessionHandle == r.phSessionHandle;
    }
    inline bool operator!=(const PhSessionHandle&l, const PhSessionHandle&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const PhSessionHandle&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,PhSessionHandle&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct PhKeyHandle : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "Mitsurugi.PhKeyHandle";
        }
        static string MD5()
        {
            return "7b010a6336d210a506b1eb4bf4c1e014";
        }
        PhKeyHandle()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            phKeyHandle = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(phKeyHandle, 0);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(phKeyHandle, 0, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["phKeyHandle"] = tars::JsonOutput::writeJson(phKeyHandle);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(phKeyHandle,pObj->value["phKeyHandle"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(phKeyHandle,"phKeyHandle");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(phKeyHandle, false);
            return _os;
        }
    public:
        tars::Int32 phKeyHandle;
    };
    inline bool operator==(const PhKeyHandle&l, const PhKeyHandle&r)
    {
        return l.phKeyHandle == r.phKeyHandle;
    }
    inline bool operator!=(const PhKeyHandle&l, const PhKeyHandle&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const PhKeyHandle&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,PhKeyHandle&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct PhAgreementHandle : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "Mitsurugi.PhAgreementHandle";
        }
        static string MD5()
        {
            return "7b010a6336d210a506b1eb4bf4c1e014";
        }
        PhAgreementHandle()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            phAgreementHandle = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(phAgreementHandle, 0);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(phAgreementHandle, 0, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["phAgreementHandle"] = tars::JsonOutput::writeJson(phAgreementHandle);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(phAgreementHandle,pObj->value["phAgreementHandle"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(phAgreementHandle,"phAgreementHandle");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(phAgreementHandle, false);
            return _os;
        }
    public:
        tars::Int32 phAgreementHandle;
    };
    inline bool operator==(const PhAgreementHandle&l, const PhAgreementHandle&r)
    {
        return l.phAgreementHandle == r.phAgreementHandle;
    }
    inline bool operator!=(const PhAgreementHandle&l, const PhAgreementHandle&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const PhAgreementHandle&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,PhAgreementHandle&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct Tars_RSArefPublicKey : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "Mitsurugi.Tars_RSArefPublicKey";
        }
        static string MD5()
        {
            return "b18e654ddfc26c475da5434086c4f5cf";
        }
        Tars_RSArefPublicKey()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            bits = 0;
            mLen = 0;
            memset(m, 0, sizeof(m));
            eLen = 0;
            memset(e, 0, sizeof(e));
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (bits != 0)
            {
                _os.write(bits, 0);
            }
            _os.write((const tars::UInt8 *)m, mLen, 1);
            _os.write((const tars::UInt8 *)e, eLen, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(bits, 0, false);
            _is.read(m, sizeof(m), mLen, 1, false);
            _is.read(e, sizeof(e), eLen, 2, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["bits"] = tars::JsonOutput::writeJson(bits);
            p->value["m"] = tars::JsonOutput::writeJson((const tars::UInt8 *)m, mLen);
            p->value["e"] = tars::JsonOutput::writeJson((const tars::UInt8 *)e, eLen);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(bits,pObj->value["bits"], false);
            tars::JsonInput::readJson(m, sizeof(m), mLen, pObj->value["m"], false);
            tars::JsonInput::readJson(e, sizeof(e), eLen, pObj->value["e"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(bits,"bits");
            _ds.display(m, mLen,"m");
            _ds.display(e, eLen,"e");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(bits, true);
            _ds.displaySimple(m, mLen,true);
            _ds.displaySimple(e, eLen,false);
            return _os;
        }
    public:
        tars::UInt32 bits;
        tars::UInt32 mLen;
        tars::UInt8 m[256];
        tars::UInt32 eLen;
        tars::UInt8 e[256];
    };
    inline bool operator==(const Tars_RSArefPublicKey&l, const Tars_RSArefPublicKey&r)
    {
        return l.bits == r.bits && !memcmp(l.m,r.m,l.mLen) && !memcmp(l.e,r.e,l.eLen);
    }
    inline bool operator!=(const Tars_RSArefPublicKey&l, const Tars_RSArefPublicKey&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const Tars_RSArefPublicKey&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,Tars_RSArefPublicKey&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct Tars_RSArefPrivateKey : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "Mitsurugi.Tars_RSArefPrivateKey";
        }
        static string MD5()
        {
            return "80433ac7f43663fb086defcb2a1b0056";
        }
        Tars_RSArefPrivateKey()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            bits = 0;
            mLen = 0;
            memset(m, 0, sizeof(m));
            eLen = 0;
            memset(e, 0, sizeof(e));
            dLen = 0;
            memset(d, 0, sizeof(d));
            primePLen = 0;
            memset(primeP, 0, sizeof(primeP));
            primeQLen = 0;
            memset(primeQ, 0, sizeof(primeQ));
            pexpDpLen = 0;
            memset(pexpDp, 0, sizeof(pexpDp));
            pexpDqLen = 0;
            memset(pexpDq, 0, sizeof(pexpDq));
            coefLen = 0;
            memset(coef, 0, sizeof(coef));
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (bits != 0)
            {
                _os.write(bits, 0);
            }
            _os.write((const tars::UInt8 *)m, mLen, 1);
            _os.write((const tars::UInt8 *)e, eLen, 2);
            _os.write((const tars::UInt8 *)d, dLen, 3);
            _os.write((const tars::UInt8 *)primeP, primePLen, 4);
            _os.write((const tars::UInt8 *)primeQ, primeQLen, 5);
            _os.write((const tars::UInt8 *)pexpDp, pexpDpLen, 6);
            _os.write((const tars::UInt8 *)pexpDq, pexpDqLen, 7);
            _os.write((const tars::UInt8 *)coef, coefLen, 8);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(bits, 0, false);
            _is.read(m, sizeof(m), mLen, 1, false);
            _is.read(e, sizeof(e), eLen, 2, false);
            _is.read(d, sizeof(d), dLen, 3, false);
            _is.read(primeP, sizeof(primeP), primePLen, 4, false);
            _is.read(primeQ, sizeof(primeQ), primeQLen, 5, false);
            _is.read(pexpDp, sizeof(pexpDp), pexpDpLen, 6, false);
            _is.read(pexpDq, sizeof(pexpDq), pexpDqLen, 7, false);
            _is.read(coef, sizeof(coef), coefLen, 8, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["bits"] = tars::JsonOutput::writeJson(bits);
            p->value["m"] = tars::JsonOutput::writeJson((const tars::UInt8 *)m, mLen);
            p->value["e"] = tars::JsonOutput::writeJson((const tars::UInt8 *)e, eLen);
            p->value["d"] = tars::JsonOutput::writeJson((const tars::UInt8 *)d, dLen);
            p->value["primeP"] = tars::JsonOutput::writeJson((const tars::UInt8 *)primeP, primePLen);
            p->value["primeQ"] = tars::JsonOutput::writeJson((const tars::UInt8 *)primeQ, primeQLen);
            p->value["pexpDp"] = tars::JsonOutput::writeJson((const tars::UInt8 *)pexpDp, pexpDpLen);
            p->value["pexpDq"] = tars::JsonOutput::writeJson((const tars::UInt8 *)pexpDq, pexpDqLen);
            p->value["coef"] = tars::JsonOutput::writeJson((const tars::UInt8 *)coef, coefLen);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(bits,pObj->value["bits"], false);
            tars::JsonInput::readJson(m, sizeof(m), mLen, pObj->value["m"], false);
            tars::JsonInput::readJson(e, sizeof(e), eLen, pObj->value["e"], false);
            tars::JsonInput::readJson(d, sizeof(d), dLen, pObj->value["d"], false);
            tars::JsonInput::readJson(primeP, sizeof(primeP), primePLen, pObj->value["primeP"], false);
            tars::JsonInput::readJson(primeQ, sizeof(primeQ), primeQLen, pObj->value["primeQ"], false);
            tars::JsonInput::readJson(pexpDp, sizeof(pexpDp), pexpDpLen, pObj->value["pexpDp"], false);
            tars::JsonInput::readJson(pexpDq, sizeof(pexpDq), pexpDqLen, pObj->value["pexpDq"], false);
            tars::JsonInput::readJson(coef, sizeof(coef), coefLen, pObj->value["coef"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(bits,"bits");
            _ds.display(m, mLen,"m");
            _ds.display(e, eLen,"e");
            _ds.display(d, dLen,"d");
            _ds.display(primeP, primePLen,"primeP");
            _ds.display(primeQ, primeQLen,"primeQ");
            _ds.display(pexpDp, pexpDpLen,"pexpDp");
            _ds.display(pexpDq, pexpDqLen,"pexpDq");
            _ds.display(coef, coefLen,"coef");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(bits, true);
            _ds.displaySimple(m, mLen,true);
            _ds.displaySimple(e, eLen,true);
            _ds.displaySimple(d, dLen,true);
            _ds.displaySimple(primeP, primePLen,true);
            _ds.displaySimple(primeQ, primeQLen,true);
            _ds.displaySimple(pexpDp, pexpDpLen,true);
            _ds.displaySimple(pexpDq, pexpDqLen,true);
            _ds.displaySimple(coef, coefLen,false);
            return _os;
        }
    public:
        tars::UInt32 bits;
        tars::UInt32 mLen;
        tars::UInt8 m[256];
        tars::UInt32 eLen;
        tars::UInt8 e[256];
        tars::UInt32 dLen;
        tars::UInt8 d[256];
        tars::UInt32 primePLen;
        tars::UInt8 primeP[128];
        tars::UInt32 primeQLen;
        tars::UInt8 primeQ[128];
        tars::UInt32 pexpDpLen;
        tars::UInt8 pexpDp[128];
        tars::UInt32 pexpDqLen;
        tars::UInt8 pexpDq[128];
        tars::UInt32 coefLen;
        tars::UInt8 coef[128];
    };
    inline bool operator==(const Tars_RSArefPrivateKey&l, const Tars_RSArefPrivateKey&r)
    {
        return l.bits == r.bits && !memcmp(l.m,r.m,l.mLen) && !memcmp(l.e,r.e,l.eLen) && !memcmp(l.d,r.d,l.dLen) && !memcmp(l.primeP,r.primeP,l.primePLen) && !memcmp(l.primeQ,r.primeQ,l.primeQLen) && !memcmp(l.pexpDp,r.pexpDp,l.pexpDpLen) && !memcmp(l.pexpDq,r.pexpDq,l.pexpDqLen) && !memcmp(l.coef,r.coef,l.coefLen);
    }
    inline bool operator!=(const Tars_RSArefPrivateKey&l, const Tars_RSArefPrivateKey&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const Tars_RSArefPrivateKey&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,Tars_RSArefPrivateKey&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct Tars_ECCrefPublicKey : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "Mitsurugi.Tars_ECCrefPublicKey";
        }
        static string MD5()
        {
            return "b18e654ddfc26c475da5434086c4f5cf";
        }
        Tars_ECCrefPublicKey()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            bits = 0;
            xLen = 0;
            memset(x, 0, sizeof(x));
            yLen = 0;
            memset(y, 0, sizeof(y));
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (bits != 0)
            {
                _os.write(bits, 0);
            }
            _os.write((const tars::UInt8 *)x, xLen, 1);
            _os.write((const tars::UInt8 *)y, yLen, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(bits, 0, false);
            _is.read(x, sizeof(x), xLen, 1, false);
            _is.read(y, sizeof(y), yLen, 2, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["bits"] = tars::JsonOutput::writeJson(bits);
            p->value["x"] = tars::JsonOutput::writeJson((const tars::UInt8 *)x, xLen);
            p->value["y"] = tars::JsonOutput::writeJson((const tars::UInt8 *)y, yLen);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(bits,pObj->value["bits"], false);
            tars::JsonInput::readJson(x, sizeof(x), xLen, pObj->value["x"], false);
            tars::JsonInput::readJson(y, sizeof(y), yLen, pObj->value["y"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(bits,"bits");
            _ds.display(x, xLen,"x");
            _ds.display(y, yLen,"y");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(bits, true);
            _ds.displaySimple(x, xLen,true);
            _ds.displaySimple(y, yLen,false);
            return _os;
        }
    public:
        tars::UInt32 bits;
        tars::UInt32 xLen;
        tars::UInt8 x[64];
        tars::UInt32 yLen;
        tars::UInt8 y[64];
    };
    inline bool operator==(const Tars_ECCrefPublicKey&l, const Tars_ECCrefPublicKey&r)
    {
        return l.bits == r.bits && !memcmp(l.x,r.x,l.xLen) && !memcmp(l.y,r.y,l.yLen);
    }
    inline bool operator!=(const Tars_ECCrefPublicKey&l, const Tars_ECCrefPublicKey&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const Tars_ECCrefPublicKey&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,Tars_ECCrefPublicKey&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct Tars_ECCrefPrivateKey : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "Mitsurugi.Tars_ECCrefPrivateKey";
        }
        static string MD5()
        {
            return "cbfdc0bb19b8e92e8e70fe983d7ed159";
        }
        Tars_ECCrefPrivateKey()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            bits = 0;
            KLen = 0;
            memset(K, 0, sizeof(K));
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (bits != 0)
            {
                _os.write(bits, 0);
            }
            _os.write((const tars::UInt8 *)K, KLen, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(bits, 0, false);
            _is.read(K, sizeof(K), KLen, 1, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["bits"] = tars::JsonOutput::writeJson(bits);
            p->value["K"] = tars::JsonOutput::writeJson((const tars::UInt8 *)K, KLen);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(bits,pObj->value["bits"], false);
            tars::JsonInput::readJson(K, sizeof(K), KLen, pObj->value["K"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(bits,"bits");
            _ds.display(K, KLen,"K");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(bits, true);
            _ds.displaySimple(K, KLen,false);
            return _os;
        }
    public:
        tars::UInt32 bits;
        tars::UInt32 KLen;
        tars::UInt8 K[64];
    };
    inline bool operator==(const Tars_ECCrefPrivateKey&l, const Tars_ECCrefPrivateKey&r)
    {
        return l.bits == r.bits && !memcmp(l.K,r.K,l.KLen);
    }
    inline bool operator!=(const Tars_ECCrefPrivateKey&l, const Tars_ECCrefPrivateKey&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const Tars_ECCrefPrivateKey&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,Tars_ECCrefPrivateKey&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct Tars_ECCCipher : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "Mitsurugi.Tars_ECCCipher";
        }
        static string MD5()
        {
            return "4b64e075b278b4768711db15659c5377";
        }
        Tars_ECCCipher()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            xLen = 0;
            memset(x, 0, sizeof(x));
            yLen = 0;
            memset(y, 0, sizeof(y));
            MLen = 0;
            memset(M, 0, sizeof(M));
            L = 0;
            CLen = 0;
            memset(C, 0, sizeof(C));
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write((const tars::UInt8 *)x, xLen, 0);
            _os.write((const tars::UInt8 *)y, yLen, 1);
            _os.write((const tars::UInt8 *)M, MLen, 2);
            if (L != 0)
            {
                _os.write(L, 3);
            }
            _os.write((const tars::UInt8 *)C, CLen, 4);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(x, sizeof(x), xLen, 0, false);
            _is.read(y, sizeof(y), yLen, 1, false);
            _is.read(M, sizeof(M), MLen, 2, false);
            _is.read(L, 3, false);
            _is.read(C, sizeof(C), CLen, 4, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["x"] = tars::JsonOutput::writeJson((const tars::UInt8 *)x, xLen);
            p->value["y"] = tars::JsonOutput::writeJson((const tars::UInt8 *)y, yLen);
            p->value["M"] = tars::JsonOutput::writeJson((const tars::UInt8 *)M, MLen);
            p->value["L"] = tars::JsonOutput::writeJson(L);
            p->value["C"] = tars::JsonOutput::writeJson((const tars::UInt8 *)C, CLen);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(x, sizeof(x), xLen, pObj->value["x"], false);
            tars::JsonInput::readJson(y, sizeof(y), yLen, pObj->value["y"], false);
            tars::JsonInput::readJson(M, sizeof(M), MLen, pObj->value["M"], false);
            tars::JsonInput::readJson(L,pObj->value["L"], false);
            tars::JsonInput::readJson(C, sizeof(C), CLen, pObj->value["C"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(x, xLen,"x");
            _ds.display(y, yLen,"y");
            _ds.display(M, MLen,"M");
            _ds.display(L,"L");
            _ds.display(C, CLen,"C");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(x, xLen,true);
            _ds.displaySimple(y, yLen,true);
            _ds.displaySimple(M, MLen,true);
            _ds.displaySimple(L, true);
            _ds.displaySimple(C, CLen,false);
            return _os;
        }
    public:
        tars::UInt32 xLen;
        tars::UInt8 x[64];
        tars::UInt32 yLen;
        tars::UInt8 y[64];
        tars::UInt32 MLen;
        tars::UInt8 M[32];
        tars::UInt32 L;
        tars::UInt32 CLen;
        tars::UInt8 C[1];
    };
    inline bool operator==(const Tars_ECCCipher&l, const Tars_ECCCipher&r)
    {
        return !memcmp(l.x,r.x,l.xLen) && !memcmp(l.y,r.y,l.yLen) && !memcmp(l.M,r.M,l.MLen) && l.L == r.L && !memcmp(l.C,r.C,l.CLen);
    }
    inline bool operator!=(const Tars_ECCCipher&l, const Tars_ECCCipher&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const Tars_ECCCipher&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,Tars_ECCCipher&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct Tars_ECCSignature : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "Mitsurugi.Tars_ECCSignature";
        }
        static string MD5()
        {
            return "d2fdff20392cb9d040f9ad8cbcc04643";
        }
        Tars_ECCSignature()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            rLen = 0;
            memset(r, 0, sizeof(r));
            sLen = 0;
            memset(s, 0, sizeof(s));
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write((const tars::UInt8 *)r, rLen, 0);
            _os.write((const tars::UInt8 *)s, sLen, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(r, sizeof(r), rLen, 0, false);
            _is.read(s, sizeof(s), sLen, 1, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["r"] = tars::JsonOutput::writeJson((const tars::UInt8 *)r, rLen);
            p->value["s"] = tars::JsonOutput::writeJson((const tars::UInt8 *)s, sLen);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(r, sizeof(r), rLen, pObj->value["r"], false);
            tars::JsonInput::readJson(s, sizeof(s), sLen, pObj->value["s"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(r, rLen,"r");
            _ds.display(s, sLen,"s");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(r, rLen,true);
            _ds.displaySimple(s, sLen,false);
            return _os;
        }
    public:
        tars::UInt32 rLen;
        tars::UInt8 r[64];
        tars::UInt32 sLen;
        tars::UInt8 s[64];
    };
    inline bool operator==(const Tars_ECCSignature&l, const Tars_ECCSignature&r)
    {
        return !memcmp(l.r,r.r,l.rLen) && !memcmp(l.s,r.s,l.sLen);
    }
    inline bool operator!=(const Tars_ECCSignature&l, const Tars_ECCSignature&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const Tars_ECCSignature&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,Tars_ECCSignature&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }


    /* callback of async proxy for client */
    class KeyManagePrxCallback: public tars::ServantProxyCallback
    {
    public:
        virtual ~KeyManagePrxCallback(){}
        virtual void callback_destroyKey(tars::Int32 ret)
        { throw std::runtime_error("callback_destroyKey() override incorrect."); }
        virtual void callback_destroyKey_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_destroyKey_exception() override incorrect."); }

        virtual void callback_exchangeDigitEncelopeBaseOnECC(tars::Int32 ret,  const Mitsurugi::Tars_ECCCipher& pucEncDataOut)
        { throw std::runtime_error("callback_exchangeDigitEncelopeBaseOnECC() override incorrect."); }
        virtual void callback_exchangeDigitEncelopeBaseOnECC_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_exchangeDigitEncelopeBaseOnECC_exception() override incorrect."); }
        virtual void callback_exchangeDigitEncelopeBaseOnECC(tars::Int32 ret, Mitsurugi::Tars_ECCCipher&&  pucEncDataOut)
        { callback_exchangeDigitEncelopeBaseOnECC(ret, pucEncDataOut); }

        virtual void callback_exchangeDigitEnvelopeBaseOnRSA(tars::Int32 ret,  const vector<tars::UInt8>& pucDEOutput, tars::UInt32 puiDELength)
        { throw std::runtime_error("callback_exchangeDigitEnvelopeBaseOnRSA() override incorrect."); }
        virtual void callback_exchangeDigitEnvelopeBaseOnRSA_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_exchangeDigitEnvelopeBaseOnRSA_exception() override incorrect."); }
        virtual void callback_exchangeDigitEnvelopeBaseOnRSA(tars::Int32 ret, vector<tars::UInt8>&&  pucDEOutput, tars::UInt32 puiDELength)
        { callback_exchangeDigitEnvelopeBaseOnRSA(ret, pucDEOutput, puiDELength); }

        virtual void callback_exportEncPublicKey_ECC(tars::Int32 ret,  const Mitsurugi::Tars_ECCrefPublicKey& pucPublicKey)
        { throw std::runtime_error("callback_exportEncPublicKey_ECC() override incorrect."); }
        virtual void callback_exportEncPublicKey_ECC_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_exportEncPublicKey_ECC_exception() override incorrect."); }
        virtual void callback_exportEncPublicKey_ECC(tars::Int32 ret, Mitsurugi::Tars_ECCrefPublicKey&&  pucPublicKey)
        { callback_exportEncPublicKey_ECC(ret, pucPublicKey); }

        virtual void callback_exportEncPublicKey_RSA(tars::Int32 ret,  const Mitsurugi::Tars_RSArefPublicKey& pucPublicKey)
        { throw std::runtime_error("callback_exportEncPublicKey_RSA() override incorrect."); }
        virtual void callback_exportEncPublicKey_RSA_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_exportEncPublicKey_RSA_exception() override incorrect."); }
        virtual void callback_exportEncPublicKey_RSA(tars::Int32 ret, Mitsurugi::Tars_RSArefPublicKey&&  pucPublicKey)
        { callback_exportEncPublicKey_RSA(ret, pucPublicKey); }

        virtual void callback_exportSignPublicKey_ECC(tars::Int32 ret,  const Mitsurugi::Tars_ECCrefPublicKey& pucPublicKey)
        { throw std::runtime_error("callback_exportSignPublicKey_ECC() override incorrect."); }
        virtual void callback_exportSignPublicKey_ECC_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_exportSignPublicKey_ECC_exception() override incorrect."); }
        virtual void callback_exportSignPublicKey_ECC(tars::Int32 ret, Mitsurugi::Tars_ECCrefPublicKey&&  pucPublicKey)
        { callback_exportSignPublicKey_ECC(ret, pucPublicKey); }

        virtual void callback_exportSignPublicKey_RSA(tars::Int32 ret,  const Mitsurugi::Tars_RSArefPublicKey& pucPublicKey)
        { throw std::runtime_error("callback_exportSignPublicKey_RSA() override incorrect."); }
        virtual void callback_exportSignPublicKey_RSA_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_exportSignPublicKey_RSA_exception() override incorrect."); }
        virtual void callback_exportSignPublicKey_RSA(tars::Int32 ret, Mitsurugi::Tars_RSArefPublicKey&&  pucPublicKey)
        { callback_exportSignPublicKey_RSA(ret, pucPublicKey); }

        virtual void callback_generateAgreementDataAndKeyWithECC(tars::Int32 ret,  const Mitsurugi::Tars_ECCrefPublicKey& pucResponsePublicKey,  const Mitsurugi::Tars_ECCrefPublicKey& pucResponseTmpPublicKey,  const Mitsurugi::PhKeyHandle& keyHandle)
        { throw std::runtime_error("callback_generateAgreementDataAndKeyWithECC() override incorrect."); }
        virtual void callback_generateAgreementDataAndKeyWithECC_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_generateAgreementDataAndKeyWithECC_exception() override incorrect."); }
        virtual void callback_generateAgreementDataAndKeyWithECC(tars::Int32 ret, Mitsurugi::Tars_ECCrefPublicKey&&  pucResponsePublicKey, Mitsurugi::Tars_ECCrefPublicKey&&  pucResponseTmpPublicKey, Mitsurugi::PhKeyHandle&&  keyHandle)
        { callback_generateAgreementDataAndKeyWithECC(ret, pucResponsePublicKey, pucResponseTmpPublicKey, keyHandle); }

        virtual void callback_generateAgreementDataWithECC(tars::Int32 ret,  const Mitsurugi::Tars_ECCrefPublicKey& pucSponsorPublicKey,  const Mitsurugi::Tars_ECCrefPublicKey& pucSponsorTmpPublicKey,  const Mitsurugi::PhAgreementHandle& agreementHandle)
        { throw std::runtime_error("callback_generateAgreementDataWithECC() override incorrect."); }
        virtual void callback_generateAgreementDataWithECC_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_generateAgreementDataWithECC_exception() override incorrect."); }
        virtual void callback_generateAgreementDataWithECC(tars::Int32 ret, Mitsurugi::Tars_ECCrefPublicKey&&  pucSponsorPublicKey, Mitsurugi::Tars_ECCrefPublicKey&&  pucSponsorTmpPublicKey, Mitsurugi::PhAgreementHandle&&  agreementHandle)
        { callback_generateAgreementDataWithECC(ret, pucSponsorPublicKey, pucSponsorTmpPublicKey, agreementHandle); }

        virtual void callback_generateKeyPair_ECC(tars::Int32 ret,  const Mitsurugi::Tars_ECCrefPublicKey& pucPublicKey,  const Mitsurugi::Tars_ECCrefPrivateKey& pucPrivateKey)
        { throw std::runtime_error("callback_generateKeyPair_ECC() override incorrect."); }
        virtual void callback_generateKeyPair_ECC_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_generateKeyPair_ECC_exception() override incorrect."); }
        virtual void callback_generateKeyPair_ECC(tars::Int32 ret, Mitsurugi::Tars_ECCrefPublicKey&&  pucPublicKey, Mitsurugi::Tars_ECCrefPrivateKey&&  pucPrivateKey)
        { callback_generateKeyPair_ECC(ret, pucPublicKey, pucPrivateKey); }

        virtual void callback_generateKeyPair_RSA(tars::Int32 ret,  const Mitsurugi::Tars_RSArefPublicKey& pucPublicKey,  const Mitsurugi::Tars_RSArefPrivateKey& pucPrivateKey)
        { throw std::runtime_error("callback_generateKeyPair_RSA() override incorrect."); }
        virtual void callback_generateKeyPair_RSA_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_generateKeyPair_RSA_exception() override incorrect."); }
        virtual void callback_generateKeyPair_RSA(tars::Int32 ret, Mitsurugi::Tars_RSArefPublicKey&&  pucPublicKey, Mitsurugi::Tars_RSArefPrivateKey&&  pucPrivateKey)
        { callback_generateKeyPair_RSA(ret, pucPublicKey, pucPrivateKey); }

        virtual void callback_generateKeyWithECC(tars::Int32 ret,  const Mitsurugi::PhKeyHandle& keyHandle)
        { throw std::runtime_error("callback_generateKeyWithECC() override incorrect."); }
        virtual void callback_generateKeyWithECC_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_generateKeyWithECC_exception() override incorrect."); }
        virtual void callback_generateKeyWithECC(tars::Int32 ret, Mitsurugi::PhKeyHandle&&  keyHandle)
        { callback_generateKeyWithECC(ret, keyHandle); }

        virtual void callback_generateKeyWithEPK_ECC(tars::Int32 ret,  const Mitsurugi::Tars_ECCCipher& pucKey,  const Mitsurugi::PhKeyHandle& keyHandle)
        { throw std::runtime_error("callback_generateKeyWithEPK_ECC() override incorrect."); }
        virtual void callback_generateKeyWithEPK_ECC_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_generateKeyWithEPK_ECC_exception() override incorrect."); }
        virtual void callback_generateKeyWithEPK_ECC(tars::Int32 ret, Mitsurugi::Tars_ECCCipher&&  pucKey, Mitsurugi::PhKeyHandle&&  keyHandle)
        { callback_generateKeyWithEPK_ECC(ret, pucKey, keyHandle); }

        virtual void callback_generateKeyWithEPK_RSA(tars::Int32 ret,  const vector<tars::UInt8>& pucKey, tars::UInt32 puiKeyLength,  const Mitsurugi::PhKeyHandle& keyHandle)
        { throw std::runtime_error("callback_generateKeyWithEPK_RSA() override incorrect."); }
        virtual void callback_generateKeyWithEPK_RSA_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_generateKeyWithEPK_RSA_exception() override incorrect."); }
        virtual void callback_generateKeyWithEPK_RSA(tars::Int32 ret, vector<tars::UInt8>&&  pucKey, tars::UInt32 puiKeyLength, Mitsurugi::PhKeyHandle&&  keyHandle)
        { callback_generateKeyWithEPK_RSA(ret, pucKey, puiKeyLength, keyHandle); }

        virtual void callback_generateKeyWithIPK_ECC(tars::Int32 ret,  const Mitsurugi::Tars_ECCCipher& pucKey,  const Mitsurugi::PhKeyHandle& keyHandle)
        { throw std::runtime_error("callback_generateKeyWithIPK_ECC() override incorrect."); }
        virtual void callback_generateKeyWithIPK_ECC_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_generateKeyWithIPK_ECC_exception() override incorrect."); }
        virtual void callback_generateKeyWithIPK_ECC(tars::Int32 ret, Mitsurugi::Tars_ECCCipher&&  pucKey, Mitsurugi::PhKeyHandle&&  keyHandle)
        { callback_generateKeyWithIPK_ECC(ret, pucKey, keyHandle); }

        virtual void callback_generateKeyWithIPK_RSA(tars::Int32 ret,  const vector<tars::UInt8>& pucKey, tars::UInt32 puiKeyLength,  const Mitsurugi::PhKeyHandle& keyHandle)
        { throw std::runtime_error("callback_generateKeyWithIPK_RSA() override incorrect."); }
        virtual void callback_generateKeyWithIPK_RSA_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_generateKeyWithIPK_RSA_exception() override incorrect."); }
        virtual void callback_generateKeyWithIPK_RSA(tars::Int32 ret, vector<tars::UInt8>&&  pucKey, tars::UInt32 puiKeyLength, Mitsurugi::PhKeyHandle&&  keyHandle)
        { callback_generateKeyWithIPK_RSA(ret, pucKey, puiKeyLength, keyHandle); }

        virtual void callback_generateKeyWithKEK(tars::Int32 ret,  const vector<tars::UInt8>& pucKey, tars::UInt32 puiKeyLength,  const Mitsurugi::PhKeyHandle& keyHandle)
        { throw std::runtime_error("callback_generateKeyWithKEK() override incorrect."); }
        virtual void callback_generateKeyWithKEK_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_generateKeyWithKEK_exception() override incorrect."); }
        virtual void callback_generateKeyWithKEK(tars::Int32 ret, vector<tars::UInt8>&&  pucKey, tars::UInt32 puiKeyLength, Mitsurugi::PhKeyHandle&&  keyHandle)
        { callback_generateKeyWithKEK(ret, pucKey, puiKeyLength, keyHandle); }

        virtual void callback_importKey(tars::Int32 ret,  const Mitsurugi::PhKeyHandle& keyHandle)
        { throw std::runtime_error("callback_importKey() override incorrect."); }
        virtual void callback_importKey_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_importKey_exception() override incorrect."); }
        virtual void callback_importKey(tars::Int32 ret, Mitsurugi::PhKeyHandle&&  keyHandle)
        { callback_importKey(ret, keyHandle); }

        virtual void callback_importKeyWithISK_ECC(tars::Int32 ret,  const Mitsurugi::PhKeyHandle& keyHandle)
        { throw std::runtime_error("callback_importKeyWithISK_ECC() override incorrect."); }
        virtual void callback_importKeyWithISK_ECC_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_importKeyWithISK_ECC_exception() override incorrect."); }
        virtual void callback_importKeyWithISK_ECC(tars::Int32 ret, Mitsurugi::PhKeyHandle&&  keyHandle)
        { callback_importKeyWithISK_ECC(ret, keyHandle); }

        virtual void callback_importKeyWithISK_RSA(tars::Int32 ret,  const Mitsurugi::PhKeyHandle& keyHandle)
        { throw std::runtime_error("callback_importKeyWithISK_RSA() override incorrect."); }
        virtual void callback_importKeyWithISK_RSA_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_importKeyWithISK_RSA_exception() override incorrect."); }
        virtual void callback_importKeyWithISK_RSA(tars::Int32 ret, Mitsurugi::PhKeyHandle&&  keyHandle)
        { callback_importKeyWithISK_RSA(ret, keyHandle); }

        virtual void callback_importKeyWithKEK(tars::Int32 ret,  const Mitsurugi::PhKeyHandle& keyHandle)
        { throw std::runtime_error("callback_importKeyWithKEK() override incorrect."); }
        virtual void callback_importKeyWithKEK_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_importKeyWithKEK_exception() override incorrect."); }
        virtual void callback_importKeyWithKEK(tars::Int32 ret, Mitsurugi::PhKeyHandle&&  keyHandle)
        { callback_importKeyWithKEK(ret, keyHandle); }

    public:
        virtual const map<std::string, std::string> & getResponseContext() const
        {
            CallbackThreadData * pCbtd = CallbackThreadData::getData();
            assert(pCbtd != NULL);

            if(!pCbtd->getContextValid())
            {
                throw TC_Exception("cann't get response context");
            }
            return pCbtd->getResponseContext();
        }

    public:
        virtual int onDispatch(tars::ReqMessagePtr _msg_)
        {
            static ::std::string __KeyManage_all[]=
            {
                "destroyKey",
                "exchangeDigitEncelopeBaseOnECC",
                "exchangeDigitEnvelopeBaseOnRSA",
                "exportEncPublicKey_ECC",
                "exportEncPublicKey_RSA",
                "exportSignPublicKey_ECC",
                "exportSignPublicKey_RSA",
                "generateAgreementDataAndKeyWithECC",
                "generateAgreementDataWithECC",
                "generateKeyPair_ECC",
                "generateKeyPair_RSA",
                "generateKeyWithECC",
                "generateKeyWithEPK_ECC",
                "generateKeyWithEPK_RSA",
                "generateKeyWithIPK_ECC",
                "generateKeyWithIPK_RSA",
                "generateKeyWithKEK",
                "importKey",
                "importKeyWithISK_ECC",
                "importKeyWithISK_RSA",
                "importKeyWithKEK"
            };
            auto it = _msg_->response->status.find("TARS_FUNC");
            pair<string*, string*> r = equal_range(__KeyManage_all, __KeyManage_all+21, (it==_msg_->response->status.end())?_msg_->request.sFuncName:it->second);
            if(r.first == r.second) return tars::TARSSERVERNOFUNCERR;
            switch(r.first - __KeyManage_all)
            {
                case 0:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_destroyKey_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, "", ServerConfig::Application + "." + ServerConfig::ServerName, "destroyKey", 0, _trace_param_, "");
                    }

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_destroyKey(_ret);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_exchangeDigitEncelopeBaseOnECC_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    Mitsurugi::Tars_ECCCipher pucEncDataOut;
                    _is.read(pucEncDataOut, 6, true);
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                            _p_->value["pucEncDataOut"] = tars::JsonOutput::writeJson(pucEncDataOut);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, "", ServerConfig::Application + "." + ServerConfig::ServerName, "exchangeDigitEncelopeBaseOnECC", 0, _trace_param_, "");
                    }

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_exchangeDigitEncelopeBaseOnECC(_ret, std::move(pucEncDataOut));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_exchangeDigitEnvelopeBaseOnRSA_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    vector<tars::UInt8> pucDEOutput;
                    _is.read(pucDEOutput, 6, true);
                    tars::UInt32 puiDELength;
                    _is.read(puiDELength, 7, true);
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                            _p_->value["pucDEOutput"] = tars::JsonOutput::writeJson(pucDEOutput);
                            _p_->value["puiDELength"] = tars::JsonOutput::writeJson(puiDELength);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, "", ServerConfig::Application + "." + ServerConfig::ServerName, "exchangeDigitEnvelopeBaseOnRSA", 0, _trace_param_, "");
                    }

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_exchangeDigitEnvelopeBaseOnRSA(_ret, std::move(pucDEOutput), puiDELength);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_exportEncPublicKey_ECC_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    Mitsurugi::Tars_ECCrefPublicKey pucPublicKey;
                    _is.read(pucPublicKey, 3, true);
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                            _p_->value["pucPublicKey"] = tars::JsonOutput::writeJson(pucPublicKey);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, "", ServerConfig::Application + "." + ServerConfig::ServerName, "exportEncPublicKey_ECC", 0, _trace_param_, "");
                    }

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_exportEncPublicKey_ECC(_ret, std::move(pucPublicKey));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 4:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_exportEncPublicKey_RSA_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    Mitsurugi::Tars_RSArefPublicKey pucPublicKey;
                    _is.read(pucPublicKey, 3, true);
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                            _p_->value["pucPublicKey"] = tars::JsonOutput::writeJson(pucPublicKey);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, "", ServerConfig::Application + "." + ServerConfig::ServerName, "exportEncPublicKey_RSA", 0, _trace_param_, "");
                    }

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_exportEncPublicKey_RSA(_ret, std::move(pucPublicKey));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 5:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_exportSignPublicKey_ECC_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    Mitsurugi::Tars_ECCrefPublicKey pucPublicKey;
                    _is.read(pucPublicKey, 3, true);
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                            _p_->value["pucPublicKey"] = tars::JsonOutput::writeJson(pucPublicKey);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, "", ServerConfig::Application + "." + ServerConfig::ServerName, "exportSignPublicKey_ECC", 0, _trace_param_, "");
                    }

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_exportSignPublicKey_ECC(_ret, std::move(pucPublicKey));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 6:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_exportSignPublicKey_RSA_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    Mitsurugi::Tars_RSArefPublicKey pucPublicKey;
                    _is.read(pucPublicKey, 3, true);
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                            _p_->value["pucPublicKey"] = tars::JsonOutput::writeJson(pucPublicKey);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, "", ServerConfig::Application + "." + ServerConfig::ServerName, "exportSignPublicKey_RSA", 0, _trace_param_, "");
                    }

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_exportSignPublicKey_RSA(_ret, std::move(pucPublicKey));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 7:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_generateAgreementDataAndKeyWithECC_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    Mitsurugi::Tars_ECCrefPublicKey pucResponsePublicKey;
                    _is.read(pucResponsePublicKey, 10, true);
                    Mitsurugi::Tars_ECCrefPublicKey pucResponseTmpPublicKey;
                    _is.read(pucResponseTmpPublicKey, 11, true);
                    Mitsurugi::PhKeyHandle keyHandle;
                    _is.read(keyHandle, 12, true);
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                            _p_->value["pucResponsePublicKey"] = tars::JsonOutput::writeJson(pucResponsePublicKey);
                            _p_->value["pucResponseTmpPublicKey"] = tars::JsonOutput::writeJson(pucResponseTmpPublicKey);
                            _p_->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, "", ServerConfig::Application + "." + ServerConfig::ServerName, "generateAgreementDataAndKeyWithECC", 0, _trace_param_, "");
                    }

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_generateAgreementDataAndKeyWithECC(_ret, std::move(pucResponsePublicKey), std::move(pucResponseTmpPublicKey), std::move(keyHandle));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 8:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_generateAgreementDataWithECC_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    Mitsurugi::Tars_ECCrefPublicKey pucSponsorPublicKey;
                    _is.read(pucSponsorPublicKey, 6, true);
                    Mitsurugi::Tars_ECCrefPublicKey pucSponsorTmpPublicKey;
                    _is.read(pucSponsorTmpPublicKey, 7, true);
                    Mitsurugi::PhAgreementHandle agreementHandle;
                    _is.read(agreementHandle, 8, true);
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                            _p_->value["pucSponsorPublicKey"] = tars::JsonOutput::writeJson(pucSponsorPublicKey);
                            _p_->value["pucSponsorTmpPublicKey"] = tars::JsonOutput::writeJson(pucSponsorTmpPublicKey);
                            _p_->value["agreementHandle"] = tars::JsonOutput::writeJson(agreementHandle);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, "", ServerConfig::Application + "." + ServerConfig::ServerName, "generateAgreementDataWithECC", 0, _trace_param_, "");
                    }

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_generateAgreementDataWithECC(_ret, std::move(pucSponsorPublicKey), std::move(pucSponsorTmpPublicKey), std::move(agreementHandle));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 9:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_generateKeyPair_ECC_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    Mitsurugi::Tars_ECCrefPublicKey pucPublicKey;
                    _is.read(pucPublicKey, 4, true);
                    Mitsurugi::Tars_ECCrefPrivateKey pucPrivateKey;
                    _is.read(pucPrivateKey, 5, true);
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                            _p_->value["pucPublicKey"] = tars::JsonOutput::writeJson(pucPublicKey);
                            _p_->value["pucPrivateKey"] = tars::JsonOutput::writeJson(pucPrivateKey);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, "", ServerConfig::Application + "." + ServerConfig::ServerName, "generateKeyPair_ECC", 0, _trace_param_, "");
                    }

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_generateKeyPair_ECC(_ret, std::move(pucPublicKey), std::move(pucPrivateKey));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 10:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_generateKeyPair_RSA_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    Mitsurugi::Tars_RSArefPublicKey pucPublicKey;
                    _is.read(pucPublicKey, 3, true);
                    Mitsurugi::Tars_RSArefPrivateKey pucPrivateKey;
                    _is.read(pucPrivateKey, 4, true);
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                            _p_->value["pucPublicKey"] = tars::JsonOutput::writeJson(pucPublicKey);
                            _p_->value["pucPrivateKey"] = tars::JsonOutput::writeJson(pucPrivateKey);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, "", ServerConfig::Application + "." + ServerConfig::ServerName, "generateKeyPair_RSA", 0, _trace_param_, "");
                    }

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_generateKeyPair_RSA(_ret, std::move(pucPublicKey), std::move(pucPrivateKey));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 11:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_generateKeyWithECC_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    Mitsurugi::PhKeyHandle keyHandle;
                    _is.read(keyHandle, 7, true);
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                            _p_->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, "", ServerConfig::Application + "." + ServerConfig::ServerName, "generateKeyWithECC", 0, _trace_param_, "");
                    }

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_generateKeyWithECC(_ret, std::move(keyHandle));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 12:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_generateKeyWithEPK_ECC_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    Mitsurugi::Tars_ECCCipher pucKey;
                    _is.read(pucKey, 5, true);
                    Mitsurugi::PhKeyHandle keyHandle;
                    _is.read(keyHandle, 6, true);
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                            _p_->value["pucKey"] = tars::JsonOutput::writeJson(pucKey);
                            _p_->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, "", ServerConfig::Application + "." + ServerConfig::ServerName, "generateKeyWithEPK_ECC", 0, _trace_param_, "");
                    }

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_generateKeyWithEPK_ECC(_ret, std::move(pucKey), std::move(keyHandle));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 13:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_generateKeyWithEPK_RSA_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    vector<tars::UInt8> pucKey;
                    _is.read(pucKey, 4, true);
                    tars::UInt32 puiKeyLength;
                    _is.read(puiKeyLength, 5, true);
                    Mitsurugi::PhKeyHandle keyHandle;
                    _is.read(keyHandle, 6, true);
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                            _p_->value["pucKey"] = tars::JsonOutput::writeJson(pucKey);
                            _p_->value["puiKeyLength"] = tars::JsonOutput::writeJson(puiKeyLength);
                            _p_->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, "", ServerConfig::Application + "." + ServerConfig::ServerName, "generateKeyWithEPK_RSA", 0, _trace_param_, "");
                    }

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_generateKeyWithEPK_RSA(_ret, std::move(pucKey), puiKeyLength, std::move(keyHandle));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 14:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_generateKeyWithIPK_ECC_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    Mitsurugi::Tars_ECCCipher pucKey;
                    _is.read(pucKey, 4, true);
                    Mitsurugi::PhKeyHandle keyHandle;
                    _is.read(keyHandle, 5, true);
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                            _p_->value["pucKey"] = tars::JsonOutput::writeJson(pucKey);
                            _p_->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, "", ServerConfig::Application + "." + ServerConfig::ServerName, "generateKeyWithIPK_ECC", 0, _trace_param_, "");
                    }

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_generateKeyWithIPK_ECC(_ret, std::move(pucKey), std::move(keyHandle));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 15:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_generateKeyWithIPK_RSA_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    vector<tars::UInt8> pucKey;
                    _is.read(pucKey, 4, true);
                    tars::UInt32 puiKeyLength;
                    _is.read(puiKeyLength, 5, true);
                    Mitsurugi::PhKeyHandle keyHandle;
                    _is.read(keyHandle, 6, true);
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                            _p_->value["pucKey"] = tars::JsonOutput::writeJson(pucKey);
                            _p_->value["puiKeyLength"] = tars::JsonOutput::writeJson(puiKeyLength);
                            _p_->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, "", ServerConfig::Application + "." + ServerConfig::ServerName, "generateKeyWithIPK_RSA", 0, _trace_param_, "");
                    }

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_generateKeyWithIPK_RSA(_ret, std::move(pucKey), puiKeyLength, std::move(keyHandle));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 16:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_generateKeyWithKEK_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    vector<tars::UInt8> pucKey;
                    _is.read(pucKey, 5, true);
                    tars::UInt32 puiKeyLength;
                    _is.read(puiKeyLength, 6, true);
                    Mitsurugi::PhKeyHandle keyHandle;
                    _is.read(keyHandle, 7, true);
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                            _p_->value["pucKey"] = tars::JsonOutput::writeJson(pucKey);
                            _p_->value["puiKeyLength"] = tars::JsonOutput::writeJson(puiKeyLength);
                            _p_->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, "", ServerConfig::Application + "." + ServerConfig::ServerName, "generateKeyWithKEK", 0, _trace_param_, "");
                    }

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_generateKeyWithKEK(_ret, std::move(pucKey), puiKeyLength, std::move(keyHandle));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 17:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_importKey_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    Mitsurugi::PhKeyHandle keyHandle;
                    _is.read(keyHandle, 4, true);
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                            _p_->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, "", ServerConfig::Application + "." + ServerConfig::ServerName, "importKey", 0, _trace_param_, "");
                    }

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_importKey(_ret, std::move(keyHandle));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 18:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_importKeyWithISK_ECC_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    Mitsurugi::PhKeyHandle keyHandle;
                    _is.read(keyHandle, 4, true);
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                            _p_->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, "", ServerConfig::Application + "." + ServerConfig::ServerName, "importKeyWithISK_ECC", 0, _trace_param_, "");
                    }

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_importKeyWithISK_ECC(_ret, std::move(keyHandle));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 19:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_importKeyWithISK_RSA_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    Mitsurugi::PhKeyHandle keyHandle;
                    _is.read(keyHandle, 5, true);
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                            _p_->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, "", ServerConfig::Application + "." + ServerConfig::ServerName, "importKeyWithISK_RSA", 0, _trace_param_, "");
                    }

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_importKeyWithISK_RSA(_ret, std::move(keyHandle));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 20:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_importKeyWithKEK_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    Mitsurugi::PhKeyHandle keyHandle;
                    _is.read(keyHandle, 6, true);
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                            _p_->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, "", ServerConfig::Application + "." + ServerConfig::ServerName, "importKeyWithKEK", 0, _trace_param_, "");
                    }

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_importKeyWithKEK(_ret, std::move(keyHandle));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
            }
            return tars::TARSSERVERNOFUNCERR;
        }

    };
    typedef tars::TC_AutoPtr<KeyManagePrxCallback> KeyManagePrxCallbackPtr;

    //callback of promise async proxy for client
    class KeyManagePrxCallbackPromise: public tars::ServantProxyCallback
    {
    public:
        virtual ~KeyManagePrxCallbackPromise(){}
    public:
        struct PromisedestroyKey: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< KeyManagePrxCallbackPromise::PromisedestroyKey > PromisedestroyKeyPtr;

        KeyManagePrxCallbackPromise(const tars::Promise< KeyManagePrxCallbackPromise::PromisedestroyKeyPtr > &promise)
        : _promise_destroyKey(promise)
        {}
        
        virtual void callback_destroyKey(const KeyManagePrxCallbackPromise::PromisedestroyKeyPtr &ptr)
        {
            _promise_destroyKey.setValue(ptr);
        }
        virtual void callback_destroyKey_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:destroyKey_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_destroyKey.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< KeyManagePrxCallbackPromise::PromisedestroyKeyPtr > _promise_destroyKey;

    public:
        struct PromiseexchangeDigitEncelopeBaseOnECC: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            Mitsurugi::Tars_ECCCipher pucEncDataOut;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< KeyManagePrxCallbackPromise::PromiseexchangeDigitEncelopeBaseOnECC > PromiseexchangeDigitEncelopeBaseOnECCPtr;

        KeyManagePrxCallbackPromise(const tars::Promise< KeyManagePrxCallbackPromise::PromiseexchangeDigitEncelopeBaseOnECCPtr > &promise)
        : _promise_exchangeDigitEncelopeBaseOnECC(promise)
        {}
        
        virtual void callback_exchangeDigitEncelopeBaseOnECC(const KeyManagePrxCallbackPromise::PromiseexchangeDigitEncelopeBaseOnECCPtr &ptr)
        {
            _promise_exchangeDigitEncelopeBaseOnECC.setValue(ptr);
        }
        virtual void callback_exchangeDigitEncelopeBaseOnECC_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:exchangeDigitEncelopeBaseOnECC_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_exchangeDigitEncelopeBaseOnECC.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< KeyManagePrxCallbackPromise::PromiseexchangeDigitEncelopeBaseOnECCPtr > _promise_exchangeDigitEncelopeBaseOnECC;

    public:
        struct PromiseexchangeDigitEnvelopeBaseOnRSA: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            vector<tars::UInt8> pucDEOutput;
            tars::UInt32 puiDELength;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< KeyManagePrxCallbackPromise::PromiseexchangeDigitEnvelopeBaseOnRSA > PromiseexchangeDigitEnvelopeBaseOnRSAPtr;

        KeyManagePrxCallbackPromise(const tars::Promise< KeyManagePrxCallbackPromise::PromiseexchangeDigitEnvelopeBaseOnRSAPtr > &promise)
        : _promise_exchangeDigitEnvelopeBaseOnRSA(promise)
        {}
        
        virtual void callback_exchangeDigitEnvelopeBaseOnRSA(const KeyManagePrxCallbackPromise::PromiseexchangeDigitEnvelopeBaseOnRSAPtr &ptr)
        {
            _promise_exchangeDigitEnvelopeBaseOnRSA.setValue(ptr);
        }
        virtual void callback_exchangeDigitEnvelopeBaseOnRSA_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:exchangeDigitEnvelopeBaseOnRSA_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_exchangeDigitEnvelopeBaseOnRSA.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< KeyManagePrxCallbackPromise::PromiseexchangeDigitEnvelopeBaseOnRSAPtr > _promise_exchangeDigitEnvelopeBaseOnRSA;

    public:
        struct PromiseexportEncPublicKey_ECC: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            Mitsurugi::Tars_ECCrefPublicKey pucPublicKey;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< KeyManagePrxCallbackPromise::PromiseexportEncPublicKey_ECC > PromiseexportEncPublicKey_ECCPtr;

        KeyManagePrxCallbackPromise(const tars::Promise< KeyManagePrxCallbackPromise::PromiseexportEncPublicKey_ECCPtr > &promise)
        : _promise_exportEncPublicKey_ECC(promise)
        {}
        
        virtual void callback_exportEncPublicKey_ECC(const KeyManagePrxCallbackPromise::PromiseexportEncPublicKey_ECCPtr &ptr)
        {
            _promise_exportEncPublicKey_ECC.setValue(ptr);
        }
        virtual void callback_exportEncPublicKey_ECC_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:exportEncPublicKey_ECC_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_exportEncPublicKey_ECC.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< KeyManagePrxCallbackPromise::PromiseexportEncPublicKey_ECCPtr > _promise_exportEncPublicKey_ECC;

    public:
        struct PromiseexportEncPublicKey_RSA: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            Mitsurugi::Tars_RSArefPublicKey pucPublicKey;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< KeyManagePrxCallbackPromise::PromiseexportEncPublicKey_RSA > PromiseexportEncPublicKey_RSAPtr;

        KeyManagePrxCallbackPromise(const tars::Promise< KeyManagePrxCallbackPromise::PromiseexportEncPublicKey_RSAPtr > &promise)
        : _promise_exportEncPublicKey_RSA(promise)
        {}
        
        virtual void callback_exportEncPublicKey_RSA(const KeyManagePrxCallbackPromise::PromiseexportEncPublicKey_RSAPtr &ptr)
        {
            _promise_exportEncPublicKey_RSA.setValue(ptr);
        }
        virtual void callback_exportEncPublicKey_RSA_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:exportEncPublicKey_RSA_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_exportEncPublicKey_RSA.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< KeyManagePrxCallbackPromise::PromiseexportEncPublicKey_RSAPtr > _promise_exportEncPublicKey_RSA;

    public:
        struct PromiseexportSignPublicKey_ECC: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            Mitsurugi::Tars_ECCrefPublicKey pucPublicKey;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< KeyManagePrxCallbackPromise::PromiseexportSignPublicKey_ECC > PromiseexportSignPublicKey_ECCPtr;

        KeyManagePrxCallbackPromise(const tars::Promise< KeyManagePrxCallbackPromise::PromiseexportSignPublicKey_ECCPtr > &promise)
        : _promise_exportSignPublicKey_ECC(promise)
        {}
        
        virtual void callback_exportSignPublicKey_ECC(const KeyManagePrxCallbackPromise::PromiseexportSignPublicKey_ECCPtr &ptr)
        {
            _promise_exportSignPublicKey_ECC.setValue(ptr);
        }
        virtual void callback_exportSignPublicKey_ECC_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:exportSignPublicKey_ECC_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_exportSignPublicKey_ECC.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< KeyManagePrxCallbackPromise::PromiseexportSignPublicKey_ECCPtr > _promise_exportSignPublicKey_ECC;

    public:
        struct PromiseexportSignPublicKey_RSA: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            Mitsurugi::Tars_RSArefPublicKey pucPublicKey;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< KeyManagePrxCallbackPromise::PromiseexportSignPublicKey_RSA > PromiseexportSignPublicKey_RSAPtr;

        KeyManagePrxCallbackPromise(const tars::Promise< KeyManagePrxCallbackPromise::PromiseexportSignPublicKey_RSAPtr > &promise)
        : _promise_exportSignPublicKey_RSA(promise)
        {}
        
        virtual void callback_exportSignPublicKey_RSA(const KeyManagePrxCallbackPromise::PromiseexportSignPublicKey_RSAPtr &ptr)
        {
            _promise_exportSignPublicKey_RSA.setValue(ptr);
        }
        virtual void callback_exportSignPublicKey_RSA_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:exportSignPublicKey_RSA_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_exportSignPublicKey_RSA.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< KeyManagePrxCallbackPromise::PromiseexportSignPublicKey_RSAPtr > _promise_exportSignPublicKey_RSA;

    public:
        struct PromisegenerateAgreementDataAndKeyWithECC: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            Mitsurugi::Tars_ECCrefPublicKey pucResponsePublicKey;
            Mitsurugi::Tars_ECCrefPublicKey pucResponseTmpPublicKey;
            Mitsurugi::PhKeyHandle keyHandle;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< KeyManagePrxCallbackPromise::PromisegenerateAgreementDataAndKeyWithECC > PromisegenerateAgreementDataAndKeyWithECCPtr;

        KeyManagePrxCallbackPromise(const tars::Promise< KeyManagePrxCallbackPromise::PromisegenerateAgreementDataAndKeyWithECCPtr > &promise)
        : _promise_generateAgreementDataAndKeyWithECC(promise)
        {}
        
        virtual void callback_generateAgreementDataAndKeyWithECC(const KeyManagePrxCallbackPromise::PromisegenerateAgreementDataAndKeyWithECCPtr &ptr)
        {
            _promise_generateAgreementDataAndKeyWithECC.setValue(ptr);
        }
        virtual void callback_generateAgreementDataAndKeyWithECC_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:generateAgreementDataAndKeyWithECC_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_generateAgreementDataAndKeyWithECC.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< KeyManagePrxCallbackPromise::PromisegenerateAgreementDataAndKeyWithECCPtr > _promise_generateAgreementDataAndKeyWithECC;

    public:
        struct PromisegenerateAgreementDataWithECC: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            Mitsurugi::Tars_ECCrefPublicKey pucSponsorPublicKey;
            Mitsurugi::Tars_ECCrefPublicKey pucSponsorTmpPublicKey;
            Mitsurugi::PhAgreementHandle agreementHandle;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< KeyManagePrxCallbackPromise::PromisegenerateAgreementDataWithECC > PromisegenerateAgreementDataWithECCPtr;

        KeyManagePrxCallbackPromise(const tars::Promise< KeyManagePrxCallbackPromise::PromisegenerateAgreementDataWithECCPtr > &promise)
        : _promise_generateAgreementDataWithECC(promise)
        {}
        
        virtual void callback_generateAgreementDataWithECC(const KeyManagePrxCallbackPromise::PromisegenerateAgreementDataWithECCPtr &ptr)
        {
            _promise_generateAgreementDataWithECC.setValue(ptr);
        }
        virtual void callback_generateAgreementDataWithECC_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:generateAgreementDataWithECC_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_generateAgreementDataWithECC.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< KeyManagePrxCallbackPromise::PromisegenerateAgreementDataWithECCPtr > _promise_generateAgreementDataWithECC;

    public:
        struct PromisegenerateKeyPair_ECC: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            Mitsurugi::Tars_ECCrefPublicKey pucPublicKey;
            Mitsurugi::Tars_ECCrefPrivateKey pucPrivateKey;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< KeyManagePrxCallbackPromise::PromisegenerateKeyPair_ECC > PromisegenerateKeyPair_ECCPtr;

        KeyManagePrxCallbackPromise(const tars::Promise< KeyManagePrxCallbackPromise::PromisegenerateKeyPair_ECCPtr > &promise)
        : _promise_generateKeyPair_ECC(promise)
        {}
        
        virtual void callback_generateKeyPair_ECC(const KeyManagePrxCallbackPromise::PromisegenerateKeyPair_ECCPtr &ptr)
        {
            _promise_generateKeyPair_ECC.setValue(ptr);
        }
        virtual void callback_generateKeyPair_ECC_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:generateKeyPair_ECC_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_generateKeyPair_ECC.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< KeyManagePrxCallbackPromise::PromisegenerateKeyPair_ECCPtr > _promise_generateKeyPair_ECC;

    public:
        struct PromisegenerateKeyPair_RSA: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            Mitsurugi::Tars_RSArefPublicKey pucPublicKey;
            Mitsurugi::Tars_RSArefPrivateKey pucPrivateKey;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< KeyManagePrxCallbackPromise::PromisegenerateKeyPair_RSA > PromisegenerateKeyPair_RSAPtr;

        KeyManagePrxCallbackPromise(const tars::Promise< KeyManagePrxCallbackPromise::PromisegenerateKeyPair_RSAPtr > &promise)
        : _promise_generateKeyPair_RSA(promise)
        {}
        
        virtual void callback_generateKeyPair_RSA(const KeyManagePrxCallbackPromise::PromisegenerateKeyPair_RSAPtr &ptr)
        {
            _promise_generateKeyPair_RSA.setValue(ptr);
        }
        virtual void callback_generateKeyPair_RSA_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:generateKeyPair_RSA_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_generateKeyPair_RSA.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< KeyManagePrxCallbackPromise::PromisegenerateKeyPair_RSAPtr > _promise_generateKeyPair_RSA;

    public:
        struct PromisegenerateKeyWithECC: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            Mitsurugi::PhKeyHandle keyHandle;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< KeyManagePrxCallbackPromise::PromisegenerateKeyWithECC > PromisegenerateKeyWithECCPtr;

        KeyManagePrxCallbackPromise(const tars::Promise< KeyManagePrxCallbackPromise::PromisegenerateKeyWithECCPtr > &promise)
        : _promise_generateKeyWithECC(promise)
        {}
        
        virtual void callback_generateKeyWithECC(const KeyManagePrxCallbackPromise::PromisegenerateKeyWithECCPtr &ptr)
        {
            _promise_generateKeyWithECC.setValue(ptr);
        }
        virtual void callback_generateKeyWithECC_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:generateKeyWithECC_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_generateKeyWithECC.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< KeyManagePrxCallbackPromise::PromisegenerateKeyWithECCPtr > _promise_generateKeyWithECC;

    public:
        struct PromisegenerateKeyWithEPK_ECC: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            Mitsurugi::Tars_ECCCipher pucKey;
            Mitsurugi::PhKeyHandle keyHandle;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< KeyManagePrxCallbackPromise::PromisegenerateKeyWithEPK_ECC > PromisegenerateKeyWithEPK_ECCPtr;

        KeyManagePrxCallbackPromise(const tars::Promise< KeyManagePrxCallbackPromise::PromisegenerateKeyWithEPK_ECCPtr > &promise)
        : _promise_generateKeyWithEPK_ECC(promise)
        {}
        
        virtual void callback_generateKeyWithEPK_ECC(const KeyManagePrxCallbackPromise::PromisegenerateKeyWithEPK_ECCPtr &ptr)
        {
            _promise_generateKeyWithEPK_ECC.setValue(ptr);
        }
        virtual void callback_generateKeyWithEPK_ECC_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:generateKeyWithEPK_ECC_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_generateKeyWithEPK_ECC.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< KeyManagePrxCallbackPromise::PromisegenerateKeyWithEPK_ECCPtr > _promise_generateKeyWithEPK_ECC;

    public:
        struct PromisegenerateKeyWithEPK_RSA: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            vector<tars::UInt8> pucKey;
            tars::UInt32 puiKeyLength;
            Mitsurugi::PhKeyHandle keyHandle;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< KeyManagePrxCallbackPromise::PromisegenerateKeyWithEPK_RSA > PromisegenerateKeyWithEPK_RSAPtr;

        KeyManagePrxCallbackPromise(const tars::Promise< KeyManagePrxCallbackPromise::PromisegenerateKeyWithEPK_RSAPtr > &promise)
        : _promise_generateKeyWithEPK_RSA(promise)
        {}
        
        virtual void callback_generateKeyWithEPK_RSA(const KeyManagePrxCallbackPromise::PromisegenerateKeyWithEPK_RSAPtr &ptr)
        {
            _promise_generateKeyWithEPK_RSA.setValue(ptr);
        }
        virtual void callback_generateKeyWithEPK_RSA_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:generateKeyWithEPK_RSA_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_generateKeyWithEPK_RSA.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< KeyManagePrxCallbackPromise::PromisegenerateKeyWithEPK_RSAPtr > _promise_generateKeyWithEPK_RSA;

    public:
        struct PromisegenerateKeyWithIPK_ECC: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            Mitsurugi::Tars_ECCCipher pucKey;
            Mitsurugi::PhKeyHandle keyHandle;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< KeyManagePrxCallbackPromise::PromisegenerateKeyWithIPK_ECC > PromisegenerateKeyWithIPK_ECCPtr;

        KeyManagePrxCallbackPromise(const tars::Promise< KeyManagePrxCallbackPromise::PromisegenerateKeyWithIPK_ECCPtr > &promise)
        : _promise_generateKeyWithIPK_ECC(promise)
        {}
        
        virtual void callback_generateKeyWithIPK_ECC(const KeyManagePrxCallbackPromise::PromisegenerateKeyWithIPK_ECCPtr &ptr)
        {
            _promise_generateKeyWithIPK_ECC.setValue(ptr);
        }
        virtual void callback_generateKeyWithIPK_ECC_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:generateKeyWithIPK_ECC_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_generateKeyWithIPK_ECC.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< KeyManagePrxCallbackPromise::PromisegenerateKeyWithIPK_ECCPtr > _promise_generateKeyWithIPK_ECC;

    public:
        struct PromisegenerateKeyWithIPK_RSA: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            vector<tars::UInt8> pucKey;
            tars::UInt32 puiKeyLength;
            Mitsurugi::PhKeyHandle keyHandle;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< KeyManagePrxCallbackPromise::PromisegenerateKeyWithIPK_RSA > PromisegenerateKeyWithIPK_RSAPtr;

        KeyManagePrxCallbackPromise(const tars::Promise< KeyManagePrxCallbackPromise::PromisegenerateKeyWithIPK_RSAPtr > &promise)
        : _promise_generateKeyWithIPK_RSA(promise)
        {}
        
        virtual void callback_generateKeyWithIPK_RSA(const KeyManagePrxCallbackPromise::PromisegenerateKeyWithIPK_RSAPtr &ptr)
        {
            _promise_generateKeyWithIPK_RSA.setValue(ptr);
        }
        virtual void callback_generateKeyWithIPK_RSA_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:generateKeyWithIPK_RSA_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_generateKeyWithIPK_RSA.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< KeyManagePrxCallbackPromise::PromisegenerateKeyWithIPK_RSAPtr > _promise_generateKeyWithIPK_RSA;

    public:
        struct PromisegenerateKeyWithKEK: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            vector<tars::UInt8> pucKey;
            tars::UInt32 puiKeyLength;
            Mitsurugi::PhKeyHandle keyHandle;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< KeyManagePrxCallbackPromise::PromisegenerateKeyWithKEK > PromisegenerateKeyWithKEKPtr;

        KeyManagePrxCallbackPromise(const tars::Promise< KeyManagePrxCallbackPromise::PromisegenerateKeyWithKEKPtr > &promise)
        : _promise_generateKeyWithKEK(promise)
        {}
        
        virtual void callback_generateKeyWithKEK(const KeyManagePrxCallbackPromise::PromisegenerateKeyWithKEKPtr &ptr)
        {
            _promise_generateKeyWithKEK.setValue(ptr);
        }
        virtual void callback_generateKeyWithKEK_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:generateKeyWithKEK_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_generateKeyWithKEK.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< KeyManagePrxCallbackPromise::PromisegenerateKeyWithKEKPtr > _promise_generateKeyWithKEK;

    public:
        struct PromiseimportKey: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            Mitsurugi::PhKeyHandle keyHandle;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< KeyManagePrxCallbackPromise::PromiseimportKey > PromiseimportKeyPtr;

        KeyManagePrxCallbackPromise(const tars::Promise< KeyManagePrxCallbackPromise::PromiseimportKeyPtr > &promise)
        : _promise_importKey(promise)
        {}
        
        virtual void callback_importKey(const KeyManagePrxCallbackPromise::PromiseimportKeyPtr &ptr)
        {
            _promise_importKey.setValue(ptr);
        }
        virtual void callback_importKey_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:importKey_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_importKey.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< KeyManagePrxCallbackPromise::PromiseimportKeyPtr > _promise_importKey;

    public:
        struct PromiseimportKeyWithISK_ECC: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            Mitsurugi::PhKeyHandle keyHandle;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< KeyManagePrxCallbackPromise::PromiseimportKeyWithISK_ECC > PromiseimportKeyWithISK_ECCPtr;

        KeyManagePrxCallbackPromise(const tars::Promise< KeyManagePrxCallbackPromise::PromiseimportKeyWithISK_ECCPtr > &promise)
        : _promise_importKeyWithISK_ECC(promise)
        {}
        
        virtual void callback_importKeyWithISK_ECC(const KeyManagePrxCallbackPromise::PromiseimportKeyWithISK_ECCPtr &ptr)
        {
            _promise_importKeyWithISK_ECC.setValue(ptr);
        }
        virtual void callback_importKeyWithISK_ECC_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:importKeyWithISK_ECC_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_importKeyWithISK_ECC.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< KeyManagePrxCallbackPromise::PromiseimportKeyWithISK_ECCPtr > _promise_importKeyWithISK_ECC;

    public:
        struct PromiseimportKeyWithISK_RSA: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            Mitsurugi::PhKeyHandle keyHandle;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< KeyManagePrxCallbackPromise::PromiseimportKeyWithISK_RSA > PromiseimportKeyWithISK_RSAPtr;

        KeyManagePrxCallbackPromise(const tars::Promise< KeyManagePrxCallbackPromise::PromiseimportKeyWithISK_RSAPtr > &promise)
        : _promise_importKeyWithISK_RSA(promise)
        {}
        
        virtual void callback_importKeyWithISK_RSA(const KeyManagePrxCallbackPromise::PromiseimportKeyWithISK_RSAPtr &ptr)
        {
            _promise_importKeyWithISK_RSA.setValue(ptr);
        }
        virtual void callback_importKeyWithISK_RSA_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:importKeyWithISK_RSA_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_importKeyWithISK_RSA.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< KeyManagePrxCallbackPromise::PromiseimportKeyWithISK_RSAPtr > _promise_importKeyWithISK_RSA;

    public:
        struct PromiseimportKeyWithKEK: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            Mitsurugi::PhKeyHandle keyHandle;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< KeyManagePrxCallbackPromise::PromiseimportKeyWithKEK > PromiseimportKeyWithKEKPtr;

        KeyManagePrxCallbackPromise(const tars::Promise< KeyManagePrxCallbackPromise::PromiseimportKeyWithKEKPtr > &promise)
        : _promise_importKeyWithKEK(promise)
        {}
        
        virtual void callback_importKeyWithKEK(const KeyManagePrxCallbackPromise::PromiseimportKeyWithKEKPtr &ptr)
        {
            _promise_importKeyWithKEK.setValue(ptr);
        }
        virtual void callback_importKeyWithKEK_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:importKeyWithKEK_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_importKeyWithKEK.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< KeyManagePrxCallbackPromise::PromiseimportKeyWithKEKPtr > _promise_importKeyWithKEK;

    public:
        virtual int onDispatch(tars::ReqMessagePtr _msg_)
        {
            static ::std::string __KeyManage_all[]=
            {
                "destroyKey",
                "exchangeDigitEncelopeBaseOnECC",
                "exchangeDigitEnvelopeBaseOnRSA",
                "exportEncPublicKey_ECC",
                "exportEncPublicKey_RSA",
                "exportSignPublicKey_ECC",
                "exportSignPublicKey_RSA",
                "generateAgreementDataAndKeyWithECC",
                "generateAgreementDataWithECC",
                "generateKeyPair_ECC",
                "generateKeyPair_RSA",
                "generateKeyWithECC",
                "generateKeyWithEPK_ECC",
                "generateKeyWithEPK_RSA",
                "generateKeyWithIPK_ECC",
                "generateKeyWithIPK_RSA",
                "generateKeyWithKEK",
                "importKey",
                "importKeyWithISK_ECC",
                "importKeyWithISK_RSA",
                "importKeyWithKEK"
            };

            pair<string*, string*> r = equal_range(__KeyManage_all, __KeyManage_all+21, string(_msg_->request.sFuncName));
            if(r.first == r.second) return tars::TARSSERVERNOFUNCERR;
            switch(r.first - __KeyManage_all)
            {
                case 0:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_destroyKey_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    KeyManagePrxCallbackPromise::PromisedestroyKeyPtr ptr = new KeyManagePrxCallbackPromise::PromisedestroyKey();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                    }
                    catch(std::exception &ex)
                    {
                        callback_destroyKey_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_destroyKey_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_destroyKey(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_exchangeDigitEncelopeBaseOnECC_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    KeyManagePrxCallbackPromise::PromiseexchangeDigitEncelopeBaseOnECCPtr ptr = new KeyManagePrxCallbackPromise::PromiseexchangeDigitEncelopeBaseOnECC();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->pucEncDataOut, 6, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_exchangeDigitEncelopeBaseOnECC_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_exchangeDigitEncelopeBaseOnECC_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_exchangeDigitEncelopeBaseOnECC(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_exchangeDigitEnvelopeBaseOnRSA_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    KeyManagePrxCallbackPromise::PromiseexchangeDigitEnvelopeBaseOnRSAPtr ptr = new KeyManagePrxCallbackPromise::PromiseexchangeDigitEnvelopeBaseOnRSA();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->pucDEOutput, 6, true);
                        _is.read(ptr->puiDELength, 7, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_exchangeDigitEnvelopeBaseOnRSA_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_exchangeDigitEnvelopeBaseOnRSA_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_exchangeDigitEnvelopeBaseOnRSA(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_exportEncPublicKey_ECC_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    KeyManagePrxCallbackPromise::PromiseexportEncPublicKey_ECCPtr ptr = new KeyManagePrxCallbackPromise::PromiseexportEncPublicKey_ECC();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->pucPublicKey, 3, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_exportEncPublicKey_ECC_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_exportEncPublicKey_ECC_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_exportEncPublicKey_ECC(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 4:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_exportEncPublicKey_RSA_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    KeyManagePrxCallbackPromise::PromiseexportEncPublicKey_RSAPtr ptr = new KeyManagePrxCallbackPromise::PromiseexportEncPublicKey_RSA();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->pucPublicKey, 3, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_exportEncPublicKey_RSA_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_exportEncPublicKey_RSA_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_exportEncPublicKey_RSA(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 5:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_exportSignPublicKey_ECC_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    KeyManagePrxCallbackPromise::PromiseexportSignPublicKey_ECCPtr ptr = new KeyManagePrxCallbackPromise::PromiseexportSignPublicKey_ECC();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->pucPublicKey, 3, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_exportSignPublicKey_ECC_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_exportSignPublicKey_ECC_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_exportSignPublicKey_ECC(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 6:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_exportSignPublicKey_RSA_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    KeyManagePrxCallbackPromise::PromiseexportSignPublicKey_RSAPtr ptr = new KeyManagePrxCallbackPromise::PromiseexportSignPublicKey_RSA();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->pucPublicKey, 3, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_exportSignPublicKey_RSA_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_exportSignPublicKey_RSA_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_exportSignPublicKey_RSA(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 7:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_generateAgreementDataAndKeyWithECC_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    KeyManagePrxCallbackPromise::PromisegenerateAgreementDataAndKeyWithECCPtr ptr = new KeyManagePrxCallbackPromise::PromisegenerateAgreementDataAndKeyWithECC();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->pucResponsePublicKey, 10, true);
                        _is.read(ptr->pucResponseTmpPublicKey, 11, true);
                        _is.read(ptr->keyHandle, 12, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_generateAgreementDataAndKeyWithECC_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_generateAgreementDataAndKeyWithECC_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_generateAgreementDataAndKeyWithECC(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 8:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_generateAgreementDataWithECC_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    KeyManagePrxCallbackPromise::PromisegenerateAgreementDataWithECCPtr ptr = new KeyManagePrxCallbackPromise::PromisegenerateAgreementDataWithECC();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->pucSponsorPublicKey, 6, true);
                        _is.read(ptr->pucSponsorTmpPublicKey, 7, true);
                        _is.read(ptr->agreementHandle, 8, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_generateAgreementDataWithECC_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_generateAgreementDataWithECC_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_generateAgreementDataWithECC(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 9:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_generateKeyPair_ECC_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    KeyManagePrxCallbackPromise::PromisegenerateKeyPair_ECCPtr ptr = new KeyManagePrxCallbackPromise::PromisegenerateKeyPair_ECC();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->pucPublicKey, 4, true);
                        _is.read(ptr->pucPrivateKey, 5, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_generateKeyPair_ECC_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_generateKeyPair_ECC_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_generateKeyPair_ECC(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 10:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_generateKeyPair_RSA_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    KeyManagePrxCallbackPromise::PromisegenerateKeyPair_RSAPtr ptr = new KeyManagePrxCallbackPromise::PromisegenerateKeyPair_RSA();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->pucPublicKey, 3, true);
                        _is.read(ptr->pucPrivateKey, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_generateKeyPair_RSA_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_generateKeyPair_RSA_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_generateKeyPair_RSA(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 11:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_generateKeyWithECC_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    KeyManagePrxCallbackPromise::PromisegenerateKeyWithECCPtr ptr = new KeyManagePrxCallbackPromise::PromisegenerateKeyWithECC();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->keyHandle, 7, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_generateKeyWithECC_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_generateKeyWithECC_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_generateKeyWithECC(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 12:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_generateKeyWithEPK_ECC_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    KeyManagePrxCallbackPromise::PromisegenerateKeyWithEPK_ECCPtr ptr = new KeyManagePrxCallbackPromise::PromisegenerateKeyWithEPK_ECC();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->pucKey, 5, true);
                        _is.read(ptr->keyHandle, 6, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_generateKeyWithEPK_ECC_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_generateKeyWithEPK_ECC_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_generateKeyWithEPK_ECC(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 13:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_generateKeyWithEPK_RSA_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    KeyManagePrxCallbackPromise::PromisegenerateKeyWithEPK_RSAPtr ptr = new KeyManagePrxCallbackPromise::PromisegenerateKeyWithEPK_RSA();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->pucKey, 4, true);
                        _is.read(ptr->puiKeyLength, 5, true);
                        _is.read(ptr->keyHandle, 6, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_generateKeyWithEPK_RSA_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_generateKeyWithEPK_RSA_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_generateKeyWithEPK_RSA(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 14:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_generateKeyWithIPK_ECC_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    KeyManagePrxCallbackPromise::PromisegenerateKeyWithIPK_ECCPtr ptr = new KeyManagePrxCallbackPromise::PromisegenerateKeyWithIPK_ECC();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->pucKey, 4, true);
                        _is.read(ptr->keyHandle, 5, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_generateKeyWithIPK_ECC_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_generateKeyWithIPK_ECC_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_generateKeyWithIPK_ECC(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 15:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_generateKeyWithIPK_RSA_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    KeyManagePrxCallbackPromise::PromisegenerateKeyWithIPK_RSAPtr ptr = new KeyManagePrxCallbackPromise::PromisegenerateKeyWithIPK_RSA();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->pucKey, 4, true);
                        _is.read(ptr->puiKeyLength, 5, true);
                        _is.read(ptr->keyHandle, 6, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_generateKeyWithIPK_RSA_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_generateKeyWithIPK_RSA_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_generateKeyWithIPK_RSA(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 16:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_generateKeyWithKEK_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    KeyManagePrxCallbackPromise::PromisegenerateKeyWithKEKPtr ptr = new KeyManagePrxCallbackPromise::PromisegenerateKeyWithKEK();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->pucKey, 5, true);
                        _is.read(ptr->puiKeyLength, 6, true);
                        _is.read(ptr->keyHandle, 7, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_generateKeyWithKEK_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_generateKeyWithKEK_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_generateKeyWithKEK(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 17:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_importKey_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    KeyManagePrxCallbackPromise::PromiseimportKeyPtr ptr = new KeyManagePrxCallbackPromise::PromiseimportKey();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->keyHandle, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_importKey_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_importKey_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_importKey(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 18:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_importKeyWithISK_ECC_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    KeyManagePrxCallbackPromise::PromiseimportKeyWithISK_ECCPtr ptr = new KeyManagePrxCallbackPromise::PromiseimportKeyWithISK_ECC();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->keyHandle, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_importKeyWithISK_ECC_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_importKeyWithISK_ECC_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_importKeyWithISK_ECC(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 19:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_importKeyWithISK_RSA_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    KeyManagePrxCallbackPromise::PromiseimportKeyWithISK_RSAPtr ptr = new KeyManagePrxCallbackPromise::PromiseimportKeyWithISK_RSA();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->keyHandle, 5, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_importKeyWithISK_RSA_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_importKeyWithISK_RSA_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_importKeyWithISK_RSA(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 20:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_importKeyWithKEK_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    KeyManagePrxCallbackPromise::PromiseimportKeyWithKEKPtr ptr = new KeyManagePrxCallbackPromise::PromiseimportKeyWithKEK();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->keyHandle, 6, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_importKeyWithKEK_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_importKeyWithKEK_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_importKeyWithKEK(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
            }
            return tars::TARSSERVERNOFUNCERR;
        }

    };
    typedef tars::TC_AutoPtr<KeyManagePrxCallbackPromise> KeyManagePrxCallbackPromisePtr;

    /* callback of coroutine async proxy for client */
    class KeyManageCoroPrxCallback: public KeyManagePrxCallback
    {
    public:
        virtual ~KeyManageCoroPrxCallback(){}
    public:
        virtual const map<std::string, std::string> & getResponseContext() const { return _mRspContext; }

        virtual void setResponseContext(const map<std::string, std::string> &mContext) { _mRspContext = mContext; }

    public:
        int onDispatch(tars::ReqMessagePtr _msg_)
        {
            static ::std::string __KeyManage_all[]=
            {
                "destroyKey",
                "exchangeDigitEncelopeBaseOnECC",
                "exchangeDigitEnvelopeBaseOnRSA",
                "exportEncPublicKey_ECC",
                "exportEncPublicKey_RSA",
                "exportSignPublicKey_ECC",
                "exportSignPublicKey_RSA",
                "generateAgreementDataAndKeyWithECC",
                "generateAgreementDataWithECC",
                "generateKeyPair_ECC",
                "generateKeyPair_RSA",
                "generateKeyWithECC",
                "generateKeyWithEPK_ECC",
                "generateKeyWithEPK_RSA",
                "generateKeyWithIPK_ECC",
                "generateKeyWithIPK_RSA",
                "generateKeyWithKEK",
                "importKey",
                "importKeyWithISK_ECC",
                "importKeyWithISK_RSA",
                "importKeyWithKEK"
            };

            pair<string*, string*> r = equal_range(__KeyManage_all, __KeyManage_all+21, string(_msg_->request.sFuncName));
            if(r.first == r.second) return tars::TARSSERVERNOFUNCERR;
            switch(r.first - __KeyManage_all)
            {
                case 0:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_destroyKey_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        setResponseContext(_msg_->response->context);

                        callback_destroyKey(_ret);

                    }
                    catch(std::exception &ex)
                    {
                        callback_destroyKey_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_destroyKey_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_exchangeDigitEncelopeBaseOnECC_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        Mitsurugi::Tars_ECCCipher pucEncDataOut;
                        _is.read(pucEncDataOut, 6, true);
                        setResponseContext(_msg_->response->context);

                        callback_exchangeDigitEncelopeBaseOnECC(_ret, std::move(pucEncDataOut));

                    }
                    catch(std::exception &ex)
                    {
                        callback_exchangeDigitEncelopeBaseOnECC_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_exchangeDigitEncelopeBaseOnECC_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_exchangeDigitEnvelopeBaseOnRSA_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        vector<tars::UInt8> pucDEOutput;
                        _is.read(pucDEOutput, 6, true);
                        tars::UInt32 puiDELength;
                        _is.read(puiDELength, 7, true);
                        setResponseContext(_msg_->response->context);

                        callback_exchangeDigitEnvelopeBaseOnRSA(_ret, std::move(pucDEOutput), puiDELength);

                    }
                    catch(std::exception &ex)
                    {
                        callback_exchangeDigitEnvelopeBaseOnRSA_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_exchangeDigitEnvelopeBaseOnRSA_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_exportEncPublicKey_ECC_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        Mitsurugi::Tars_ECCrefPublicKey pucPublicKey;
                        _is.read(pucPublicKey, 3, true);
                        setResponseContext(_msg_->response->context);

                        callback_exportEncPublicKey_ECC(_ret, std::move(pucPublicKey));

                    }
                    catch(std::exception &ex)
                    {
                        callback_exportEncPublicKey_ECC_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_exportEncPublicKey_ECC_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 4:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_exportEncPublicKey_RSA_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        Mitsurugi::Tars_RSArefPublicKey pucPublicKey;
                        _is.read(pucPublicKey, 3, true);
                        setResponseContext(_msg_->response->context);

                        callback_exportEncPublicKey_RSA(_ret, std::move(pucPublicKey));

                    }
                    catch(std::exception &ex)
                    {
                        callback_exportEncPublicKey_RSA_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_exportEncPublicKey_RSA_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 5:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_exportSignPublicKey_ECC_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        Mitsurugi::Tars_ECCrefPublicKey pucPublicKey;
                        _is.read(pucPublicKey, 3, true);
                        setResponseContext(_msg_->response->context);

                        callback_exportSignPublicKey_ECC(_ret, std::move(pucPublicKey));

                    }
                    catch(std::exception &ex)
                    {
                        callback_exportSignPublicKey_ECC_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_exportSignPublicKey_ECC_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 6:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_exportSignPublicKey_RSA_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        Mitsurugi::Tars_RSArefPublicKey pucPublicKey;
                        _is.read(pucPublicKey, 3, true);
                        setResponseContext(_msg_->response->context);

                        callback_exportSignPublicKey_RSA(_ret, std::move(pucPublicKey));

                    }
                    catch(std::exception &ex)
                    {
                        callback_exportSignPublicKey_RSA_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_exportSignPublicKey_RSA_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 7:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_generateAgreementDataAndKeyWithECC_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        Mitsurugi::Tars_ECCrefPublicKey pucResponsePublicKey;
                        _is.read(pucResponsePublicKey, 10, true);
                        Mitsurugi::Tars_ECCrefPublicKey pucResponseTmpPublicKey;
                        _is.read(pucResponseTmpPublicKey, 11, true);
                        Mitsurugi::PhKeyHandle keyHandle;
                        _is.read(keyHandle, 12, true);
                        setResponseContext(_msg_->response->context);

                        callback_generateAgreementDataAndKeyWithECC(_ret, std::move(pucResponsePublicKey), std::move(pucResponseTmpPublicKey), std::move(keyHandle));

                    }
                    catch(std::exception &ex)
                    {
                        callback_generateAgreementDataAndKeyWithECC_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_generateAgreementDataAndKeyWithECC_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 8:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_generateAgreementDataWithECC_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        Mitsurugi::Tars_ECCrefPublicKey pucSponsorPublicKey;
                        _is.read(pucSponsorPublicKey, 6, true);
                        Mitsurugi::Tars_ECCrefPublicKey pucSponsorTmpPublicKey;
                        _is.read(pucSponsorTmpPublicKey, 7, true);
                        Mitsurugi::PhAgreementHandle agreementHandle;
                        _is.read(agreementHandle, 8, true);
                        setResponseContext(_msg_->response->context);

                        callback_generateAgreementDataWithECC(_ret, std::move(pucSponsorPublicKey), std::move(pucSponsorTmpPublicKey), std::move(agreementHandle));

                    }
                    catch(std::exception &ex)
                    {
                        callback_generateAgreementDataWithECC_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_generateAgreementDataWithECC_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 9:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_generateKeyPair_ECC_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        Mitsurugi::Tars_ECCrefPublicKey pucPublicKey;
                        _is.read(pucPublicKey, 4, true);
                        Mitsurugi::Tars_ECCrefPrivateKey pucPrivateKey;
                        _is.read(pucPrivateKey, 5, true);
                        setResponseContext(_msg_->response->context);

                        callback_generateKeyPair_ECC(_ret, std::move(pucPublicKey), std::move(pucPrivateKey));

                    }
                    catch(std::exception &ex)
                    {
                        callback_generateKeyPair_ECC_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_generateKeyPair_ECC_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 10:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_generateKeyPair_RSA_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        Mitsurugi::Tars_RSArefPublicKey pucPublicKey;
                        _is.read(pucPublicKey, 3, true);
                        Mitsurugi::Tars_RSArefPrivateKey pucPrivateKey;
                        _is.read(pucPrivateKey, 4, true);
                        setResponseContext(_msg_->response->context);

                        callback_generateKeyPair_RSA(_ret, std::move(pucPublicKey), std::move(pucPrivateKey));

                    }
                    catch(std::exception &ex)
                    {
                        callback_generateKeyPair_RSA_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_generateKeyPair_RSA_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 11:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_generateKeyWithECC_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        Mitsurugi::PhKeyHandle keyHandle;
                        _is.read(keyHandle, 7, true);
                        setResponseContext(_msg_->response->context);

                        callback_generateKeyWithECC(_ret, std::move(keyHandle));

                    }
                    catch(std::exception &ex)
                    {
                        callback_generateKeyWithECC_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_generateKeyWithECC_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 12:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_generateKeyWithEPK_ECC_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        Mitsurugi::Tars_ECCCipher pucKey;
                        _is.read(pucKey, 5, true);
                        Mitsurugi::PhKeyHandle keyHandle;
                        _is.read(keyHandle, 6, true);
                        setResponseContext(_msg_->response->context);

                        callback_generateKeyWithEPK_ECC(_ret, std::move(pucKey), std::move(keyHandle));

                    }
                    catch(std::exception &ex)
                    {
                        callback_generateKeyWithEPK_ECC_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_generateKeyWithEPK_ECC_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 13:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_generateKeyWithEPK_RSA_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        vector<tars::UInt8> pucKey;
                        _is.read(pucKey, 4, true);
                        tars::UInt32 puiKeyLength;
                        _is.read(puiKeyLength, 5, true);
                        Mitsurugi::PhKeyHandle keyHandle;
                        _is.read(keyHandle, 6, true);
                        setResponseContext(_msg_->response->context);

                        callback_generateKeyWithEPK_RSA(_ret, std::move(pucKey), puiKeyLength, std::move(keyHandle));

                    }
                    catch(std::exception &ex)
                    {
                        callback_generateKeyWithEPK_RSA_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_generateKeyWithEPK_RSA_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 14:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_generateKeyWithIPK_ECC_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        Mitsurugi::Tars_ECCCipher pucKey;
                        _is.read(pucKey, 4, true);
                        Mitsurugi::PhKeyHandle keyHandle;
                        _is.read(keyHandle, 5, true);
                        setResponseContext(_msg_->response->context);

                        callback_generateKeyWithIPK_ECC(_ret, std::move(pucKey), std::move(keyHandle));

                    }
                    catch(std::exception &ex)
                    {
                        callback_generateKeyWithIPK_ECC_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_generateKeyWithIPK_ECC_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 15:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_generateKeyWithIPK_RSA_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        vector<tars::UInt8> pucKey;
                        _is.read(pucKey, 4, true);
                        tars::UInt32 puiKeyLength;
                        _is.read(puiKeyLength, 5, true);
                        Mitsurugi::PhKeyHandle keyHandle;
                        _is.read(keyHandle, 6, true);
                        setResponseContext(_msg_->response->context);

                        callback_generateKeyWithIPK_RSA(_ret, std::move(pucKey), puiKeyLength, std::move(keyHandle));

                    }
                    catch(std::exception &ex)
                    {
                        callback_generateKeyWithIPK_RSA_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_generateKeyWithIPK_RSA_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 16:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_generateKeyWithKEK_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        vector<tars::UInt8> pucKey;
                        _is.read(pucKey, 5, true);
                        tars::UInt32 puiKeyLength;
                        _is.read(puiKeyLength, 6, true);
                        Mitsurugi::PhKeyHandle keyHandle;
                        _is.read(keyHandle, 7, true);
                        setResponseContext(_msg_->response->context);

                        callback_generateKeyWithKEK(_ret, std::move(pucKey), puiKeyLength, std::move(keyHandle));

                    }
                    catch(std::exception &ex)
                    {
                        callback_generateKeyWithKEK_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_generateKeyWithKEK_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 17:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_importKey_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        Mitsurugi::PhKeyHandle keyHandle;
                        _is.read(keyHandle, 4, true);
                        setResponseContext(_msg_->response->context);

                        callback_importKey(_ret, std::move(keyHandle));

                    }
                    catch(std::exception &ex)
                    {
                        callback_importKey_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_importKey_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 18:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_importKeyWithISK_ECC_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        Mitsurugi::PhKeyHandle keyHandle;
                        _is.read(keyHandle, 4, true);
                        setResponseContext(_msg_->response->context);

                        callback_importKeyWithISK_ECC(_ret, std::move(keyHandle));

                    }
                    catch(std::exception &ex)
                    {
                        callback_importKeyWithISK_ECC_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_importKeyWithISK_ECC_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 19:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_importKeyWithISK_RSA_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        Mitsurugi::PhKeyHandle keyHandle;
                        _is.read(keyHandle, 5, true);
                        setResponseContext(_msg_->response->context);

                        callback_importKeyWithISK_RSA(_ret, std::move(keyHandle));

                    }
                    catch(std::exception &ex)
                    {
                        callback_importKeyWithISK_RSA_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_importKeyWithISK_RSA_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 20:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_importKeyWithKEK_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        Mitsurugi::PhKeyHandle keyHandle;
                        _is.read(keyHandle, 6, true);
                        setResponseContext(_msg_->response->context);

                        callback_importKeyWithKEK(_ret, std::move(keyHandle));

                    }
                    catch(std::exception &ex)
                    {
                        callback_importKeyWithKEK_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_importKeyWithKEK_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
            }
            return tars::TARSSERVERNOFUNCERR;
        }

    protected:
        map<std::string, std::string> _mRspContext;
    };
    typedef tars::TC_AutoPtr<KeyManageCoroPrxCallback> KeyManageCoroPrxCallbackPtr;

    /* proxy for client */
    class KeyManageProxy : public tars::ServantProxy
    {
    public:
        typedef map<string, string> TARS_CONTEXT;
        tars::Int32 destroyKey(const Mitsurugi::PhSessionHandle & sessionHandle,const Mitsurugi::PhKeyHandle & keyHandle,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(keyHandle, 2);
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                    _p_->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "destroyKey", 0, _trace_param_, "");
            }

            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"destroyKey", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "destroyKey", 0, _trace_param_, "");
            }

            return _ret;
        }

        void async_destroyKey(KeyManagePrxCallbackPtr callback,const Mitsurugi::PhSessionHandle &sessionHandle,const Mitsurugi::PhKeyHandle &keyHandle,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(keyHandle, 2);
            std::map<string, string> _mStatus;
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                    _p_->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "destroyKey", 0, _trace_param_, "");
            }
            tars_invoke_async(tars::TARSNORMAL,"destroyKey", _os, context, _mStatus, callback);
        }
        
        tars::Future< KeyManagePrxCallbackPromise::PromisedestroyKeyPtr > promise_async_destroyKey(const Mitsurugi::PhSessionHandle &sessionHandle,const Mitsurugi::PhKeyHandle &keyHandle,const map<string, string>& context)
        {
            tars::Promise< KeyManagePrxCallbackPromise::PromisedestroyKeyPtr > promise;
            KeyManagePrxCallbackPromisePtr callback = new KeyManagePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(keyHandle, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"destroyKey", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_destroyKey(KeyManageCoroPrxCallbackPtr callback,const Mitsurugi::PhSessionHandle &sessionHandle,const Mitsurugi::PhKeyHandle &keyHandle,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(keyHandle, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"destroyKey", _os, context, _mStatus, callback, true);
        }

        tars::Int32 exchangeDigitEncelopeBaseOnECC(const Mitsurugi::PhSessionHandle & sessionHandle,tars::UInt32 uiKeyIndex,tars::UInt32 uiAlgID,const Mitsurugi::Tars_ECCrefPublicKey & pucPublicKey,const Mitsurugi::Tars_ECCCipher & pucEncDataIn,Mitsurugi::Tars_ECCCipher &pucEncDataOut,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiKeyIndex, 2);
            _os.write(uiAlgID, 3);
            _os.write(pucPublicKey, 4);
            _os.write(pucEncDataIn, 5);
            _os.write(pucEncDataOut, 6);
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                    _p_->value["uiKeyIndex"] = tars::JsonOutput::writeJson(uiKeyIndex);
                    _p_->value["uiAlgID"] = tars::JsonOutput::writeJson(uiAlgID);
                    _p_->value["pucPublicKey"] = tars::JsonOutput::writeJson(pucPublicKey);
                    _p_->value["pucEncDataIn"] = tars::JsonOutput::writeJson(pucEncDataIn);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "exchangeDigitEncelopeBaseOnECC", 0, _trace_param_, "");
            }

            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"exchangeDigitEncelopeBaseOnECC", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(pucEncDataOut, 6, true);
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["pucEncDataOut"] = tars::JsonOutput::writeJson(pucEncDataOut);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "exchangeDigitEncelopeBaseOnECC", 0, _trace_param_, "");
            }

            return _ret;
        }

        void async_exchangeDigitEncelopeBaseOnECC(KeyManagePrxCallbackPtr callback,const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiKeyIndex,tars::UInt32 uiAlgID,const Mitsurugi::Tars_ECCrefPublicKey &pucPublicKey,const Mitsurugi::Tars_ECCCipher &pucEncDataIn,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiKeyIndex, 2);
            _os.write(uiAlgID, 3);
            _os.write(pucPublicKey, 4);
            _os.write(pucEncDataIn, 5);
            std::map<string, string> _mStatus;
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                    _p_->value["uiKeyIndex"] = tars::JsonOutput::writeJson(uiKeyIndex);
                    _p_->value["uiAlgID"] = tars::JsonOutput::writeJson(uiAlgID);
                    _p_->value["pucPublicKey"] = tars::JsonOutput::writeJson(pucPublicKey);
                    _p_->value["pucEncDataIn"] = tars::JsonOutput::writeJson(pucEncDataIn);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "exchangeDigitEncelopeBaseOnECC", 0, _trace_param_, "");
            }
            tars_invoke_async(tars::TARSNORMAL,"exchangeDigitEncelopeBaseOnECC", _os, context, _mStatus, callback);
        }
        
        tars::Future< KeyManagePrxCallbackPromise::PromiseexchangeDigitEncelopeBaseOnECCPtr > promise_async_exchangeDigitEncelopeBaseOnECC(const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiKeyIndex,tars::UInt32 uiAlgID,const Mitsurugi::Tars_ECCrefPublicKey &pucPublicKey,const Mitsurugi::Tars_ECCCipher &pucEncDataIn,const map<string, string>& context)
        {
            tars::Promise< KeyManagePrxCallbackPromise::PromiseexchangeDigitEncelopeBaseOnECCPtr > promise;
            KeyManagePrxCallbackPromisePtr callback = new KeyManagePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiKeyIndex, 2);
            _os.write(uiAlgID, 3);
            _os.write(pucPublicKey, 4);
            _os.write(pucEncDataIn, 5);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"exchangeDigitEncelopeBaseOnECC", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_exchangeDigitEncelopeBaseOnECC(KeyManageCoroPrxCallbackPtr callback,const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiKeyIndex,tars::UInt32 uiAlgID,const Mitsurugi::Tars_ECCrefPublicKey &pucPublicKey,const Mitsurugi::Tars_ECCCipher &pucEncDataIn,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiKeyIndex, 2);
            _os.write(uiAlgID, 3);
            _os.write(pucPublicKey, 4);
            _os.write(pucEncDataIn, 5);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"exchangeDigitEncelopeBaseOnECC", _os, context, _mStatus, callback, true);
        }

        tars::Int32 exchangeDigitEnvelopeBaseOnRSA(const Mitsurugi::PhSessionHandle & sessionHandle,tars::UInt32 uiKeyIndex,const Mitsurugi::Tars_RSArefPublicKey & pucPublicKey,const vector<tars::UInt8> & pucDEInput,tars::UInt32 uiDELength,vector<tars::UInt8> &pucDEOutput,tars::UInt32 &puiDELength,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiKeyIndex, 2);
            _os.write(pucPublicKey, 3);
            _os.write(pucDEInput, 4);
            _os.write(uiDELength, 5);
            _os.write(pucDEOutput, 6);
            _os.write(puiDELength, 7);
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                    _p_->value["uiKeyIndex"] = tars::JsonOutput::writeJson(uiKeyIndex);
                    _p_->value["pucPublicKey"] = tars::JsonOutput::writeJson(pucPublicKey);
                    _p_->value["pucDEInput"] = tars::JsonOutput::writeJson(pucDEInput);
                    _p_->value["uiDELength"] = tars::JsonOutput::writeJson(uiDELength);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "exchangeDigitEnvelopeBaseOnRSA", 0, _trace_param_, "");
            }

            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"exchangeDigitEnvelopeBaseOnRSA", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(pucDEOutput, 6, true);
            _is.read(puiDELength, 7, true);
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["pucDEOutput"] = tars::JsonOutput::writeJson(pucDEOutput);
                    _p_->value["puiDELength"] = tars::JsonOutput::writeJson(puiDELength);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "exchangeDigitEnvelopeBaseOnRSA", 0, _trace_param_, "");
            }

            return _ret;
        }

        void async_exchangeDigitEnvelopeBaseOnRSA(KeyManagePrxCallbackPtr callback,const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiKeyIndex,const Mitsurugi::Tars_RSArefPublicKey &pucPublicKey,const vector<tars::UInt8> &pucDEInput,tars::UInt32 uiDELength,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiKeyIndex, 2);
            _os.write(pucPublicKey, 3);
            _os.write(pucDEInput, 4);
            _os.write(uiDELength, 5);
            std::map<string, string> _mStatus;
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                    _p_->value["uiKeyIndex"] = tars::JsonOutput::writeJson(uiKeyIndex);
                    _p_->value["pucPublicKey"] = tars::JsonOutput::writeJson(pucPublicKey);
                    _p_->value["pucDEInput"] = tars::JsonOutput::writeJson(pucDEInput);
                    _p_->value["uiDELength"] = tars::JsonOutput::writeJson(uiDELength);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "exchangeDigitEnvelopeBaseOnRSA", 0, _trace_param_, "");
            }
            tars_invoke_async(tars::TARSNORMAL,"exchangeDigitEnvelopeBaseOnRSA", _os, context, _mStatus, callback);
        }
        
        tars::Future< KeyManagePrxCallbackPromise::PromiseexchangeDigitEnvelopeBaseOnRSAPtr > promise_async_exchangeDigitEnvelopeBaseOnRSA(const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiKeyIndex,const Mitsurugi::Tars_RSArefPublicKey &pucPublicKey,const vector<tars::UInt8> &pucDEInput,tars::UInt32 uiDELength,const map<string, string>& context)
        {
            tars::Promise< KeyManagePrxCallbackPromise::PromiseexchangeDigitEnvelopeBaseOnRSAPtr > promise;
            KeyManagePrxCallbackPromisePtr callback = new KeyManagePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiKeyIndex, 2);
            _os.write(pucPublicKey, 3);
            _os.write(pucDEInput, 4);
            _os.write(uiDELength, 5);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"exchangeDigitEnvelopeBaseOnRSA", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_exchangeDigitEnvelopeBaseOnRSA(KeyManageCoroPrxCallbackPtr callback,const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiKeyIndex,const Mitsurugi::Tars_RSArefPublicKey &pucPublicKey,const vector<tars::UInt8> &pucDEInput,tars::UInt32 uiDELength,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiKeyIndex, 2);
            _os.write(pucPublicKey, 3);
            _os.write(pucDEInput, 4);
            _os.write(uiDELength, 5);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"exchangeDigitEnvelopeBaseOnRSA", _os, context, _mStatus, callback, true);
        }

        tars::Int32 exportEncPublicKey_ECC(const Mitsurugi::PhSessionHandle & sessionHandle,tars::UInt32 uiKeyIndex,Mitsurugi::Tars_ECCrefPublicKey &pucPublicKey,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiKeyIndex, 2);
            _os.write(pucPublicKey, 3);
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                    _p_->value["uiKeyIndex"] = tars::JsonOutput::writeJson(uiKeyIndex);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "exportEncPublicKey_ECC", 0, _trace_param_, "");
            }

            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"exportEncPublicKey_ECC", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(pucPublicKey, 3, true);
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["pucPublicKey"] = tars::JsonOutput::writeJson(pucPublicKey);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "exportEncPublicKey_ECC", 0, _trace_param_, "");
            }

            return _ret;
        }

        void async_exportEncPublicKey_ECC(KeyManagePrxCallbackPtr callback,const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiKeyIndex,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiKeyIndex, 2);
            std::map<string, string> _mStatus;
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                    _p_->value["uiKeyIndex"] = tars::JsonOutput::writeJson(uiKeyIndex);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "exportEncPublicKey_ECC", 0, _trace_param_, "");
            }
            tars_invoke_async(tars::TARSNORMAL,"exportEncPublicKey_ECC", _os, context, _mStatus, callback);
        }
        
        tars::Future< KeyManagePrxCallbackPromise::PromiseexportEncPublicKey_ECCPtr > promise_async_exportEncPublicKey_ECC(const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiKeyIndex,const map<string, string>& context)
        {
            tars::Promise< KeyManagePrxCallbackPromise::PromiseexportEncPublicKey_ECCPtr > promise;
            KeyManagePrxCallbackPromisePtr callback = new KeyManagePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiKeyIndex, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"exportEncPublicKey_ECC", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_exportEncPublicKey_ECC(KeyManageCoroPrxCallbackPtr callback,const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiKeyIndex,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiKeyIndex, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"exportEncPublicKey_ECC", _os, context, _mStatus, callback, true);
        }

        tars::Int32 exportEncPublicKey_RSA(const Mitsurugi::PhSessionHandle & sessionHandle,tars::UInt32 uiKeyIndex,Mitsurugi::Tars_RSArefPublicKey &pucPublicKey,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiKeyIndex, 2);
            _os.write(pucPublicKey, 3);
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                    _p_->value["uiKeyIndex"] = tars::JsonOutput::writeJson(uiKeyIndex);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "exportEncPublicKey_RSA", 0, _trace_param_, "");
            }

            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"exportEncPublicKey_RSA", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(pucPublicKey, 3, true);
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["pucPublicKey"] = tars::JsonOutput::writeJson(pucPublicKey);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "exportEncPublicKey_RSA", 0, _trace_param_, "");
            }

            return _ret;
        }

        void async_exportEncPublicKey_RSA(KeyManagePrxCallbackPtr callback,const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiKeyIndex,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiKeyIndex, 2);
            std::map<string, string> _mStatus;
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                    _p_->value["uiKeyIndex"] = tars::JsonOutput::writeJson(uiKeyIndex);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "exportEncPublicKey_RSA", 0, _trace_param_, "");
            }
            tars_invoke_async(tars::TARSNORMAL,"exportEncPublicKey_RSA", _os, context, _mStatus, callback);
        }
        
        tars::Future< KeyManagePrxCallbackPromise::PromiseexportEncPublicKey_RSAPtr > promise_async_exportEncPublicKey_RSA(const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiKeyIndex,const map<string, string>& context)
        {
            tars::Promise< KeyManagePrxCallbackPromise::PromiseexportEncPublicKey_RSAPtr > promise;
            KeyManagePrxCallbackPromisePtr callback = new KeyManagePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiKeyIndex, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"exportEncPublicKey_RSA", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_exportEncPublicKey_RSA(KeyManageCoroPrxCallbackPtr callback,const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiKeyIndex,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiKeyIndex, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"exportEncPublicKey_RSA", _os, context, _mStatus, callback, true);
        }

        tars::Int32 exportSignPublicKey_ECC(const Mitsurugi::PhSessionHandle & sessionHandle,tars::UInt32 uiKeyIndex,Mitsurugi::Tars_ECCrefPublicKey &pucPublicKey,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiKeyIndex, 2);
            _os.write(pucPublicKey, 3);
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                    _p_->value["uiKeyIndex"] = tars::JsonOutput::writeJson(uiKeyIndex);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "exportSignPublicKey_ECC", 0, _trace_param_, "");
            }

            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"exportSignPublicKey_ECC", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(pucPublicKey, 3, true);
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["pucPublicKey"] = tars::JsonOutput::writeJson(pucPublicKey);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "exportSignPublicKey_ECC", 0, _trace_param_, "");
            }

            return _ret;
        }

        void async_exportSignPublicKey_ECC(KeyManagePrxCallbackPtr callback,const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiKeyIndex,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiKeyIndex, 2);
            std::map<string, string> _mStatus;
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                    _p_->value["uiKeyIndex"] = tars::JsonOutput::writeJson(uiKeyIndex);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "exportSignPublicKey_ECC", 0, _trace_param_, "");
            }
            tars_invoke_async(tars::TARSNORMAL,"exportSignPublicKey_ECC", _os, context, _mStatus, callback);
        }
        
        tars::Future< KeyManagePrxCallbackPromise::PromiseexportSignPublicKey_ECCPtr > promise_async_exportSignPublicKey_ECC(const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiKeyIndex,const map<string, string>& context)
        {
            tars::Promise< KeyManagePrxCallbackPromise::PromiseexportSignPublicKey_ECCPtr > promise;
            KeyManagePrxCallbackPromisePtr callback = new KeyManagePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiKeyIndex, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"exportSignPublicKey_ECC", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_exportSignPublicKey_ECC(KeyManageCoroPrxCallbackPtr callback,const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiKeyIndex,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiKeyIndex, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"exportSignPublicKey_ECC", _os, context, _mStatus, callback, true);
        }

        tars::Int32 exportSignPublicKey_RSA(const Mitsurugi::PhSessionHandle & sessionHandle,tars::UInt32 uiKeyIndex,Mitsurugi::Tars_RSArefPublicKey &pucPublicKey,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiKeyIndex, 2);
            _os.write(pucPublicKey, 3);
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                    _p_->value["uiKeyIndex"] = tars::JsonOutput::writeJson(uiKeyIndex);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "exportSignPublicKey_RSA", 0, _trace_param_, "");
            }

            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"exportSignPublicKey_RSA", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(pucPublicKey, 3, true);
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["pucPublicKey"] = tars::JsonOutput::writeJson(pucPublicKey);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "exportSignPublicKey_RSA", 0, _trace_param_, "");
            }

            return _ret;
        }

        void async_exportSignPublicKey_RSA(KeyManagePrxCallbackPtr callback,const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiKeyIndex,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiKeyIndex, 2);
            std::map<string, string> _mStatus;
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                    _p_->value["uiKeyIndex"] = tars::JsonOutput::writeJson(uiKeyIndex);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "exportSignPublicKey_RSA", 0, _trace_param_, "");
            }
            tars_invoke_async(tars::TARSNORMAL,"exportSignPublicKey_RSA", _os, context, _mStatus, callback);
        }
        
        tars::Future< KeyManagePrxCallbackPromise::PromiseexportSignPublicKey_RSAPtr > promise_async_exportSignPublicKey_RSA(const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiKeyIndex,const map<string, string>& context)
        {
            tars::Promise< KeyManagePrxCallbackPromise::PromiseexportSignPublicKey_RSAPtr > promise;
            KeyManagePrxCallbackPromisePtr callback = new KeyManagePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiKeyIndex, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"exportSignPublicKey_RSA", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_exportSignPublicKey_RSA(KeyManageCoroPrxCallbackPtr callback,const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiKeyIndex,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiKeyIndex, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"exportSignPublicKey_RSA", _os, context, _mStatus, callback, true);
        }

        tars::Int32 generateAgreementDataAndKeyWithECC(const Mitsurugi::PhSessionHandle & sessionHandle,tars::UInt32 uiISKIndex,tars::UInt32 uiKeyBits,const vector<tars::UInt8> & pucResponseID,tars::UInt32 uiResponseIDLength,const vector<tars::UInt8> & pucSponsorID,tars::UInt32 uiSponsorIDLength,const Mitsurugi::Tars_ECCrefPublicKey & pucSponsorPublicKey,const Mitsurugi::Tars_ECCrefPublicKey & pucSponsorTmpPublicKey,Mitsurugi::Tars_ECCrefPublicKey &pucResponsePublicKey,Mitsurugi::Tars_ECCrefPublicKey &pucResponseTmpPublicKey,Mitsurugi::PhKeyHandle &keyHandle,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiISKIndex, 2);
            _os.write(uiKeyBits, 3);
            _os.write(pucResponseID, 4);
            _os.write(uiResponseIDLength, 5);
            _os.write(pucSponsorID, 6);
            _os.write(uiSponsorIDLength, 7);
            _os.write(pucSponsorPublicKey, 8);
            _os.write(pucSponsorTmpPublicKey, 9);
            _os.write(pucResponsePublicKey, 10);
            _os.write(pucResponseTmpPublicKey, 11);
            _os.write(keyHandle, 12);
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                    _p_->value["uiISKIndex"] = tars::JsonOutput::writeJson(uiISKIndex);
                    _p_->value["uiKeyBits"] = tars::JsonOutput::writeJson(uiKeyBits);
                    _p_->value["pucResponseID"] = tars::JsonOutput::writeJson(pucResponseID);
                    _p_->value["uiResponseIDLength"] = tars::JsonOutput::writeJson(uiResponseIDLength);
                    _p_->value["pucSponsorID"] = tars::JsonOutput::writeJson(pucSponsorID);
                    _p_->value["uiSponsorIDLength"] = tars::JsonOutput::writeJson(uiSponsorIDLength);
                    _p_->value["pucSponsorPublicKey"] = tars::JsonOutput::writeJson(pucSponsorPublicKey);
                    _p_->value["pucSponsorTmpPublicKey"] = tars::JsonOutput::writeJson(pucSponsorTmpPublicKey);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "generateAgreementDataAndKeyWithECC", 0, _trace_param_, "");
            }

            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"generateAgreementDataAndKeyWithECC", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(pucResponsePublicKey, 10, true);
            _is.read(pucResponseTmpPublicKey, 11, true);
            _is.read(keyHandle, 12, true);
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["pucResponsePublicKey"] = tars::JsonOutput::writeJson(pucResponsePublicKey);
                    _p_->value["pucResponseTmpPublicKey"] = tars::JsonOutput::writeJson(pucResponseTmpPublicKey);
                    _p_->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "generateAgreementDataAndKeyWithECC", 0, _trace_param_, "");
            }

            return _ret;
        }

        void async_generateAgreementDataAndKeyWithECC(KeyManagePrxCallbackPtr callback,const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiISKIndex,tars::UInt32 uiKeyBits,const vector<tars::UInt8> &pucResponseID,tars::UInt32 uiResponseIDLength,const vector<tars::UInt8> &pucSponsorID,tars::UInt32 uiSponsorIDLength,const Mitsurugi::Tars_ECCrefPublicKey &pucSponsorPublicKey,const Mitsurugi::Tars_ECCrefPublicKey &pucSponsorTmpPublicKey,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiISKIndex, 2);
            _os.write(uiKeyBits, 3);
            _os.write(pucResponseID, 4);
            _os.write(uiResponseIDLength, 5);
            _os.write(pucSponsorID, 6);
            _os.write(uiSponsorIDLength, 7);
            _os.write(pucSponsorPublicKey, 8);
            _os.write(pucSponsorTmpPublicKey, 9);
            std::map<string, string> _mStatus;
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                    _p_->value["uiISKIndex"] = tars::JsonOutput::writeJson(uiISKIndex);
                    _p_->value["uiKeyBits"] = tars::JsonOutput::writeJson(uiKeyBits);
                    _p_->value["pucResponseID"] = tars::JsonOutput::writeJson(pucResponseID);
                    _p_->value["uiResponseIDLength"] = tars::JsonOutput::writeJson(uiResponseIDLength);
                    _p_->value["pucSponsorID"] = tars::JsonOutput::writeJson(pucSponsorID);
                    _p_->value["uiSponsorIDLength"] = tars::JsonOutput::writeJson(uiSponsorIDLength);
                    _p_->value["pucSponsorPublicKey"] = tars::JsonOutput::writeJson(pucSponsorPublicKey);
                    _p_->value["pucSponsorTmpPublicKey"] = tars::JsonOutput::writeJson(pucSponsorTmpPublicKey);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "generateAgreementDataAndKeyWithECC", 0, _trace_param_, "");
            }
            tars_invoke_async(tars::TARSNORMAL,"generateAgreementDataAndKeyWithECC", _os, context, _mStatus, callback);
        }
        
        tars::Future< KeyManagePrxCallbackPromise::PromisegenerateAgreementDataAndKeyWithECCPtr > promise_async_generateAgreementDataAndKeyWithECC(const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiISKIndex,tars::UInt32 uiKeyBits,const vector<tars::UInt8> &pucResponseID,tars::UInt32 uiResponseIDLength,const vector<tars::UInt8> &pucSponsorID,tars::UInt32 uiSponsorIDLength,const Mitsurugi::Tars_ECCrefPublicKey &pucSponsorPublicKey,const Mitsurugi::Tars_ECCrefPublicKey &pucSponsorTmpPublicKey,const map<string, string>& context)
        {
            tars::Promise< KeyManagePrxCallbackPromise::PromisegenerateAgreementDataAndKeyWithECCPtr > promise;
            KeyManagePrxCallbackPromisePtr callback = new KeyManagePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiISKIndex, 2);
            _os.write(uiKeyBits, 3);
            _os.write(pucResponseID, 4);
            _os.write(uiResponseIDLength, 5);
            _os.write(pucSponsorID, 6);
            _os.write(uiSponsorIDLength, 7);
            _os.write(pucSponsorPublicKey, 8);
            _os.write(pucSponsorTmpPublicKey, 9);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"generateAgreementDataAndKeyWithECC", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_generateAgreementDataAndKeyWithECC(KeyManageCoroPrxCallbackPtr callback,const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiISKIndex,tars::UInt32 uiKeyBits,const vector<tars::UInt8> &pucResponseID,tars::UInt32 uiResponseIDLength,const vector<tars::UInt8> &pucSponsorID,tars::UInt32 uiSponsorIDLength,const Mitsurugi::Tars_ECCrefPublicKey &pucSponsorPublicKey,const Mitsurugi::Tars_ECCrefPublicKey &pucSponsorTmpPublicKey,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiISKIndex, 2);
            _os.write(uiKeyBits, 3);
            _os.write(pucResponseID, 4);
            _os.write(uiResponseIDLength, 5);
            _os.write(pucSponsorID, 6);
            _os.write(uiSponsorIDLength, 7);
            _os.write(pucSponsorPublicKey, 8);
            _os.write(pucSponsorTmpPublicKey, 9);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"generateAgreementDataAndKeyWithECC", _os, context, _mStatus, callback, true);
        }

        tars::Int32 generateAgreementDataWithECC(const Mitsurugi::PhSessionHandle & sessionHandle,tars::UInt32 uiISKIndex,tars::UInt32 uiKeyBits,const vector<tars::UInt8> & pucSponsorID,tars::UInt32 uiSponsorIDLength,Mitsurugi::Tars_ECCrefPublicKey &pucSponsorPublicKey,Mitsurugi::Tars_ECCrefPublicKey &pucSponsorTmpPublicKey,Mitsurugi::PhAgreementHandle &agreementHandle,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiISKIndex, 2);
            _os.write(uiKeyBits, 3);
            _os.write(pucSponsorID, 4);
            _os.write(uiSponsorIDLength, 5);
            _os.write(pucSponsorPublicKey, 6);
            _os.write(pucSponsorTmpPublicKey, 7);
            _os.write(agreementHandle, 8);
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                    _p_->value["uiISKIndex"] = tars::JsonOutput::writeJson(uiISKIndex);
                    _p_->value["uiKeyBits"] = tars::JsonOutput::writeJson(uiKeyBits);
                    _p_->value["pucSponsorID"] = tars::JsonOutput::writeJson(pucSponsorID);
                    _p_->value["uiSponsorIDLength"] = tars::JsonOutput::writeJson(uiSponsorIDLength);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "generateAgreementDataWithECC", 0, _trace_param_, "");
            }

            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"generateAgreementDataWithECC", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(pucSponsorPublicKey, 6, true);
            _is.read(pucSponsorTmpPublicKey, 7, true);
            _is.read(agreementHandle, 8, true);
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["pucSponsorPublicKey"] = tars::JsonOutput::writeJson(pucSponsorPublicKey);
                    _p_->value["pucSponsorTmpPublicKey"] = tars::JsonOutput::writeJson(pucSponsorTmpPublicKey);
                    _p_->value["agreementHandle"] = tars::JsonOutput::writeJson(agreementHandle);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "generateAgreementDataWithECC", 0, _trace_param_, "");
            }

            return _ret;
        }

        void async_generateAgreementDataWithECC(KeyManagePrxCallbackPtr callback,const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiISKIndex,tars::UInt32 uiKeyBits,const vector<tars::UInt8> &pucSponsorID,tars::UInt32 uiSponsorIDLength,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiISKIndex, 2);
            _os.write(uiKeyBits, 3);
            _os.write(pucSponsorID, 4);
            _os.write(uiSponsorIDLength, 5);
            std::map<string, string> _mStatus;
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                    _p_->value["uiISKIndex"] = tars::JsonOutput::writeJson(uiISKIndex);
                    _p_->value["uiKeyBits"] = tars::JsonOutput::writeJson(uiKeyBits);
                    _p_->value["pucSponsorID"] = tars::JsonOutput::writeJson(pucSponsorID);
                    _p_->value["uiSponsorIDLength"] = tars::JsonOutput::writeJson(uiSponsorIDLength);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "generateAgreementDataWithECC", 0, _trace_param_, "");
            }
            tars_invoke_async(tars::TARSNORMAL,"generateAgreementDataWithECC", _os, context, _mStatus, callback);
        }
        
        tars::Future< KeyManagePrxCallbackPromise::PromisegenerateAgreementDataWithECCPtr > promise_async_generateAgreementDataWithECC(const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiISKIndex,tars::UInt32 uiKeyBits,const vector<tars::UInt8> &pucSponsorID,tars::UInt32 uiSponsorIDLength,const map<string, string>& context)
        {
            tars::Promise< KeyManagePrxCallbackPromise::PromisegenerateAgreementDataWithECCPtr > promise;
            KeyManagePrxCallbackPromisePtr callback = new KeyManagePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiISKIndex, 2);
            _os.write(uiKeyBits, 3);
            _os.write(pucSponsorID, 4);
            _os.write(uiSponsorIDLength, 5);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"generateAgreementDataWithECC", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_generateAgreementDataWithECC(KeyManageCoroPrxCallbackPtr callback,const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiISKIndex,tars::UInt32 uiKeyBits,const vector<tars::UInt8> &pucSponsorID,tars::UInt32 uiSponsorIDLength,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiISKIndex, 2);
            _os.write(uiKeyBits, 3);
            _os.write(pucSponsorID, 4);
            _os.write(uiSponsorIDLength, 5);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"generateAgreementDataWithECC", _os, context, _mStatus, callback, true);
        }

        tars::Int32 generateKeyPair_ECC(const Mitsurugi::PhSessionHandle & sessionHandle,tars::UInt32 uiAlgID,tars::UInt32 uiKeyBits,Mitsurugi::Tars_ECCrefPublicKey &pucPublicKey,Mitsurugi::Tars_ECCrefPrivateKey &pucPrivateKey,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiAlgID, 2);
            _os.write(uiKeyBits, 3);
            _os.write(pucPublicKey, 4);
            _os.write(pucPrivateKey, 5);
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                    _p_->value["uiAlgID"] = tars::JsonOutput::writeJson(uiAlgID);
                    _p_->value["uiKeyBits"] = tars::JsonOutput::writeJson(uiKeyBits);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "generateKeyPair_ECC", 0, _trace_param_, "");
            }

            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"generateKeyPair_ECC", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(pucPublicKey, 4, true);
            _is.read(pucPrivateKey, 5, true);
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["pucPublicKey"] = tars::JsonOutput::writeJson(pucPublicKey);
                    _p_->value["pucPrivateKey"] = tars::JsonOutput::writeJson(pucPrivateKey);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "generateKeyPair_ECC", 0, _trace_param_, "");
            }

            return _ret;
        }

        void async_generateKeyPair_ECC(KeyManagePrxCallbackPtr callback,const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiAlgID,tars::UInt32 uiKeyBits,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiAlgID, 2);
            _os.write(uiKeyBits, 3);
            std::map<string, string> _mStatus;
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                    _p_->value["uiAlgID"] = tars::JsonOutput::writeJson(uiAlgID);
                    _p_->value["uiKeyBits"] = tars::JsonOutput::writeJson(uiKeyBits);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "generateKeyPair_ECC", 0, _trace_param_, "");
            }
            tars_invoke_async(tars::TARSNORMAL,"generateKeyPair_ECC", _os, context, _mStatus, callback);
        }
        
        tars::Future< KeyManagePrxCallbackPromise::PromisegenerateKeyPair_ECCPtr > promise_async_generateKeyPair_ECC(const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiAlgID,tars::UInt32 uiKeyBits,const map<string, string>& context)
        {
            tars::Promise< KeyManagePrxCallbackPromise::PromisegenerateKeyPair_ECCPtr > promise;
            KeyManagePrxCallbackPromisePtr callback = new KeyManagePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiAlgID, 2);
            _os.write(uiKeyBits, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"generateKeyPair_ECC", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_generateKeyPair_ECC(KeyManageCoroPrxCallbackPtr callback,const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiAlgID,tars::UInt32 uiKeyBits,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiAlgID, 2);
            _os.write(uiKeyBits, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"generateKeyPair_ECC", _os, context, _mStatus, callback, true);
        }

        tars::Int32 generateKeyPair_RSA(const Mitsurugi::PhSessionHandle & sessionHandle,tars::UInt32 uiKeyBits,Mitsurugi::Tars_RSArefPublicKey &pucPublicKey,Mitsurugi::Tars_RSArefPrivateKey &pucPrivateKey,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiKeyBits, 2);
            _os.write(pucPublicKey, 3);
            _os.write(pucPrivateKey, 4);
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                    _p_->value["uiKeyBits"] = tars::JsonOutput::writeJson(uiKeyBits);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "generateKeyPair_RSA", 0, _trace_param_, "");
            }

            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"generateKeyPair_RSA", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(pucPublicKey, 3, true);
            _is.read(pucPrivateKey, 4, true);
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["pucPublicKey"] = tars::JsonOutput::writeJson(pucPublicKey);
                    _p_->value["pucPrivateKey"] = tars::JsonOutput::writeJson(pucPrivateKey);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "generateKeyPair_RSA", 0, _trace_param_, "");
            }

            return _ret;
        }

        void async_generateKeyPair_RSA(KeyManagePrxCallbackPtr callback,const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiKeyBits,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiKeyBits, 2);
            std::map<string, string> _mStatus;
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                    _p_->value["uiKeyBits"] = tars::JsonOutput::writeJson(uiKeyBits);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "generateKeyPair_RSA", 0, _trace_param_, "");
            }
            tars_invoke_async(tars::TARSNORMAL,"generateKeyPair_RSA", _os, context, _mStatus, callback);
        }
        
        tars::Future< KeyManagePrxCallbackPromise::PromisegenerateKeyPair_RSAPtr > promise_async_generateKeyPair_RSA(const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiKeyBits,const map<string, string>& context)
        {
            tars::Promise< KeyManagePrxCallbackPromise::PromisegenerateKeyPair_RSAPtr > promise;
            KeyManagePrxCallbackPromisePtr callback = new KeyManagePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiKeyBits, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"generateKeyPair_RSA", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_generateKeyPair_RSA(KeyManageCoroPrxCallbackPtr callback,const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiKeyBits,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiKeyBits, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"generateKeyPair_RSA", _os, context, _mStatus, callback, true);
        }

        tars::Int32 generateKeyWithECC(const Mitsurugi::PhSessionHandle & sessionHandle,const vector<tars::UInt8> & pucResponseID,tars::UInt32 uiResponseIDLength,const Mitsurugi::Tars_ECCrefPublicKey & pucResponsePublicKey,const Mitsurugi::Tars_ECCrefPublicKey & pucResponseTmpPublicKey,const Mitsurugi::PhAgreementHandle & agreementHandle,Mitsurugi::PhKeyHandle &keyHandle,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(pucResponseID, 2);
            _os.write(uiResponseIDLength, 3);
            _os.write(pucResponsePublicKey, 4);
            _os.write(pucResponseTmpPublicKey, 5);
            _os.write(agreementHandle, 6);
            _os.write(keyHandle, 7);
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                    _p_->value["pucResponseID"] = tars::JsonOutput::writeJson(pucResponseID);
                    _p_->value["uiResponseIDLength"] = tars::JsonOutput::writeJson(uiResponseIDLength);
                    _p_->value["pucResponsePublicKey"] = tars::JsonOutput::writeJson(pucResponsePublicKey);
                    _p_->value["pucResponseTmpPublicKey"] = tars::JsonOutput::writeJson(pucResponseTmpPublicKey);
                    _p_->value["agreementHandle"] = tars::JsonOutput::writeJson(agreementHandle);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "generateKeyWithECC", 0, _trace_param_, "");
            }

            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"generateKeyWithECC", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(keyHandle, 7, true);
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "generateKeyWithECC", 0, _trace_param_, "");
            }

            return _ret;
        }

        void async_generateKeyWithECC(KeyManagePrxCallbackPtr callback,const Mitsurugi::PhSessionHandle &sessionHandle,const vector<tars::UInt8> &pucResponseID,tars::UInt32 uiResponseIDLength,const Mitsurugi::Tars_ECCrefPublicKey &pucResponsePublicKey,const Mitsurugi::Tars_ECCrefPublicKey &pucResponseTmpPublicKey,const Mitsurugi::PhAgreementHandle &agreementHandle,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(pucResponseID, 2);
            _os.write(uiResponseIDLength, 3);
            _os.write(pucResponsePublicKey, 4);
            _os.write(pucResponseTmpPublicKey, 5);
            _os.write(agreementHandle, 6);
            std::map<string, string> _mStatus;
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                    _p_->value["pucResponseID"] = tars::JsonOutput::writeJson(pucResponseID);
                    _p_->value["uiResponseIDLength"] = tars::JsonOutput::writeJson(uiResponseIDLength);
                    _p_->value["pucResponsePublicKey"] = tars::JsonOutput::writeJson(pucResponsePublicKey);
                    _p_->value["pucResponseTmpPublicKey"] = tars::JsonOutput::writeJson(pucResponseTmpPublicKey);
                    _p_->value["agreementHandle"] = tars::JsonOutput::writeJson(agreementHandle);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "generateKeyWithECC", 0, _trace_param_, "");
            }
            tars_invoke_async(tars::TARSNORMAL,"generateKeyWithECC", _os, context, _mStatus, callback);
        }
        
        tars::Future< KeyManagePrxCallbackPromise::PromisegenerateKeyWithECCPtr > promise_async_generateKeyWithECC(const Mitsurugi::PhSessionHandle &sessionHandle,const vector<tars::UInt8> &pucResponseID,tars::UInt32 uiResponseIDLength,const Mitsurugi::Tars_ECCrefPublicKey &pucResponsePublicKey,const Mitsurugi::Tars_ECCrefPublicKey &pucResponseTmpPublicKey,const Mitsurugi::PhAgreementHandle &agreementHandle,const map<string, string>& context)
        {
            tars::Promise< KeyManagePrxCallbackPromise::PromisegenerateKeyWithECCPtr > promise;
            KeyManagePrxCallbackPromisePtr callback = new KeyManagePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(pucResponseID, 2);
            _os.write(uiResponseIDLength, 3);
            _os.write(pucResponsePublicKey, 4);
            _os.write(pucResponseTmpPublicKey, 5);
            _os.write(agreementHandle, 6);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"generateKeyWithECC", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_generateKeyWithECC(KeyManageCoroPrxCallbackPtr callback,const Mitsurugi::PhSessionHandle &sessionHandle,const vector<tars::UInt8> &pucResponseID,tars::UInt32 uiResponseIDLength,const Mitsurugi::Tars_ECCrefPublicKey &pucResponsePublicKey,const Mitsurugi::Tars_ECCrefPublicKey &pucResponseTmpPublicKey,const Mitsurugi::PhAgreementHandle &agreementHandle,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(pucResponseID, 2);
            _os.write(uiResponseIDLength, 3);
            _os.write(pucResponsePublicKey, 4);
            _os.write(pucResponseTmpPublicKey, 5);
            _os.write(agreementHandle, 6);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"generateKeyWithECC", _os, context, _mStatus, callback, true);
        }

        tars::Int32 generateKeyWithEPK_ECC(const Mitsurugi::PhSessionHandle & sessionHandle,tars::UInt32 uiKeyBits,tars::UInt32 uiAlgID,const Mitsurugi::Tars_ECCrefPublicKey & pucPublicKey,Mitsurugi::Tars_ECCCipher &pucKey,Mitsurugi::PhKeyHandle &keyHandle,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiKeyBits, 2);
            _os.write(uiAlgID, 3);
            _os.write(pucPublicKey, 4);
            _os.write(pucKey, 5);
            _os.write(keyHandle, 6);
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                    _p_->value["uiKeyBits"] = tars::JsonOutput::writeJson(uiKeyBits);
                    _p_->value["uiAlgID"] = tars::JsonOutput::writeJson(uiAlgID);
                    _p_->value["pucPublicKey"] = tars::JsonOutput::writeJson(pucPublicKey);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "generateKeyWithEPK_ECC", 0, _trace_param_, "");
            }

            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"generateKeyWithEPK_ECC", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(pucKey, 5, true);
            _is.read(keyHandle, 6, true);
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["pucKey"] = tars::JsonOutput::writeJson(pucKey);
                    _p_->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "generateKeyWithEPK_ECC", 0, _trace_param_, "");
            }

            return _ret;
        }

        void async_generateKeyWithEPK_ECC(KeyManagePrxCallbackPtr callback,const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiKeyBits,tars::UInt32 uiAlgID,const Mitsurugi::Tars_ECCrefPublicKey &pucPublicKey,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiKeyBits, 2);
            _os.write(uiAlgID, 3);
            _os.write(pucPublicKey, 4);
            std::map<string, string> _mStatus;
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                    _p_->value["uiKeyBits"] = tars::JsonOutput::writeJson(uiKeyBits);
                    _p_->value["uiAlgID"] = tars::JsonOutput::writeJson(uiAlgID);
                    _p_->value["pucPublicKey"] = tars::JsonOutput::writeJson(pucPublicKey);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "generateKeyWithEPK_ECC", 0, _trace_param_, "");
            }
            tars_invoke_async(tars::TARSNORMAL,"generateKeyWithEPK_ECC", _os, context, _mStatus, callback);
        }
        
        tars::Future< KeyManagePrxCallbackPromise::PromisegenerateKeyWithEPK_ECCPtr > promise_async_generateKeyWithEPK_ECC(const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiKeyBits,tars::UInt32 uiAlgID,const Mitsurugi::Tars_ECCrefPublicKey &pucPublicKey,const map<string, string>& context)
        {
            tars::Promise< KeyManagePrxCallbackPromise::PromisegenerateKeyWithEPK_ECCPtr > promise;
            KeyManagePrxCallbackPromisePtr callback = new KeyManagePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiKeyBits, 2);
            _os.write(uiAlgID, 3);
            _os.write(pucPublicKey, 4);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"generateKeyWithEPK_ECC", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_generateKeyWithEPK_ECC(KeyManageCoroPrxCallbackPtr callback,const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiKeyBits,tars::UInt32 uiAlgID,const Mitsurugi::Tars_ECCrefPublicKey &pucPublicKey,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiKeyBits, 2);
            _os.write(uiAlgID, 3);
            _os.write(pucPublicKey, 4);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"generateKeyWithEPK_ECC", _os, context, _mStatus, callback, true);
        }

        tars::Int32 generateKeyWithEPK_RSA(const Mitsurugi::PhSessionHandle & sessionHandle,tars::UInt32 uiKeyBits,const Mitsurugi::Tars_RSArefPublicKey & pucPublicKey,vector<tars::UInt8> &pucKey,tars::UInt32 &puiKeyLength,Mitsurugi::PhKeyHandle &keyHandle,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiKeyBits, 2);
            _os.write(pucPublicKey, 3);
            _os.write(pucKey, 4);
            _os.write(puiKeyLength, 5);
            _os.write(keyHandle, 6);
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                    _p_->value["uiKeyBits"] = tars::JsonOutput::writeJson(uiKeyBits);
                    _p_->value["pucPublicKey"] = tars::JsonOutput::writeJson(pucPublicKey);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "generateKeyWithEPK_RSA", 0, _trace_param_, "");
            }

            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"generateKeyWithEPK_RSA", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(pucKey, 4, true);
            _is.read(puiKeyLength, 5, true);
            _is.read(keyHandle, 6, true);
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["pucKey"] = tars::JsonOutput::writeJson(pucKey);
                    _p_->value["puiKeyLength"] = tars::JsonOutput::writeJson(puiKeyLength);
                    _p_->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "generateKeyWithEPK_RSA", 0, _trace_param_, "");
            }

            return _ret;
        }

        void async_generateKeyWithEPK_RSA(KeyManagePrxCallbackPtr callback,const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiKeyBits,const Mitsurugi::Tars_RSArefPublicKey &pucPublicKey,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiKeyBits, 2);
            _os.write(pucPublicKey, 3);
            std::map<string, string> _mStatus;
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                    _p_->value["uiKeyBits"] = tars::JsonOutput::writeJson(uiKeyBits);
                    _p_->value["pucPublicKey"] = tars::JsonOutput::writeJson(pucPublicKey);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "generateKeyWithEPK_RSA", 0, _trace_param_, "");
            }
            tars_invoke_async(tars::TARSNORMAL,"generateKeyWithEPK_RSA", _os, context, _mStatus, callback);
        }
        
        tars::Future< KeyManagePrxCallbackPromise::PromisegenerateKeyWithEPK_RSAPtr > promise_async_generateKeyWithEPK_RSA(const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiKeyBits,const Mitsurugi::Tars_RSArefPublicKey &pucPublicKey,const map<string, string>& context)
        {
            tars::Promise< KeyManagePrxCallbackPromise::PromisegenerateKeyWithEPK_RSAPtr > promise;
            KeyManagePrxCallbackPromisePtr callback = new KeyManagePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiKeyBits, 2);
            _os.write(pucPublicKey, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"generateKeyWithEPK_RSA", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_generateKeyWithEPK_RSA(KeyManageCoroPrxCallbackPtr callback,const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiKeyBits,const Mitsurugi::Tars_RSArefPublicKey &pucPublicKey,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiKeyBits, 2);
            _os.write(pucPublicKey, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"generateKeyWithEPK_RSA", _os, context, _mStatus, callback, true);
        }

        tars::Int32 generateKeyWithIPK_ECC(const Mitsurugi::PhSessionHandle & sessionHandle,tars::UInt32 uiIPKIndex,tars::UInt32 uiKeyBits,Mitsurugi::Tars_ECCCipher &pucKey,Mitsurugi::PhKeyHandle &keyHandle,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiIPKIndex, 2);
            _os.write(uiKeyBits, 3);
            _os.write(pucKey, 4);
            _os.write(keyHandle, 5);
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                    _p_->value["uiIPKIndex"] = tars::JsonOutput::writeJson(uiIPKIndex);
                    _p_->value["uiKeyBits"] = tars::JsonOutput::writeJson(uiKeyBits);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "generateKeyWithIPK_ECC", 0, _trace_param_, "");
            }

            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"generateKeyWithIPK_ECC", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(pucKey, 4, true);
            _is.read(keyHandle, 5, true);
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["pucKey"] = tars::JsonOutput::writeJson(pucKey);
                    _p_->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "generateKeyWithIPK_ECC", 0, _trace_param_, "");
            }

            return _ret;
        }

        void async_generateKeyWithIPK_ECC(KeyManagePrxCallbackPtr callback,const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiIPKIndex,tars::UInt32 uiKeyBits,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiIPKIndex, 2);
            _os.write(uiKeyBits, 3);
            std::map<string, string> _mStatus;
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                    _p_->value["uiIPKIndex"] = tars::JsonOutput::writeJson(uiIPKIndex);
                    _p_->value["uiKeyBits"] = tars::JsonOutput::writeJson(uiKeyBits);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "generateKeyWithIPK_ECC", 0, _trace_param_, "");
            }
            tars_invoke_async(tars::TARSNORMAL,"generateKeyWithIPK_ECC", _os, context, _mStatus, callback);
        }
        
        tars::Future< KeyManagePrxCallbackPromise::PromisegenerateKeyWithIPK_ECCPtr > promise_async_generateKeyWithIPK_ECC(const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiIPKIndex,tars::UInt32 uiKeyBits,const map<string, string>& context)
        {
            tars::Promise< KeyManagePrxCallbackPromise::PromisegenerateKeyWithIPK_ECCPtr > promise;
            KeyManagePrxCallbackPromisePtr callback = new KeyManagePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiIPKIndex, 2);
            _os.write(uiKeyBits, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"generateKeyWithIPK_ECC", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_generateKeyWithIPK_ECC(KeyManageCoroPrxCallbackPtr callback,const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiIPKIndex,tars::UInt32 uiKeyBits,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiIPKIndex, 2);
            _os.write(uiKeyBits, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"generateKeyWithIPK_ECC", _os, context, _mStatus, callback, true);
        }

        tars::Int32 generateKeyWithIPK_RSA(const Mitsurugi::PhSessionHandle & sessionHandle,tars::UInt32 uiPKIIndex,tars::UInt32 uiKeyBits,vector<tars::UInt8> &pucKey,tars::UInt32 &puiKeyLength,Mitsurugi::PhKeyHandle &keyHandle,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiPKIIndex, 2);
            _os.write(uiKeyBits, 3);
            _os.write(pucKey, 4);
            _os.write(puiKeyLength, 5);
            _os.write(keyHandle, 6);
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                    _p_->value["uiPKIIndex"] = tars::JsonOutput::writeJson(uiPKIIndex);
                    _p_->value["uiKeyBits"] = tars::JsonOutput::writeJson(uiKeyBits);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "generateKeyWithIPK_RSA", 0, _trace_param_, "");
            }

            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"generateKeyWithIPK_RSA", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(pucKey, 4, true);
            _is.read(puiKeyLength, 5, true);
            _is.read(keyHandle, 6, true);
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["pucKey"] = tars::JsonOutput::writeJson(pucKey);
                    _p_->value["puiKeyLength"] = tars::JsonOutput::writeJson(puiKeyLength);
                    _p_->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "generateKeyWithIPK_RSA", 0, _trace_param_, "");
            }

            return _ret;
        }

        void async_generateKeyWithIPK_RSA(KeyManagePrxCallbackPtr callback,const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiPKIIndex,tars::UInt32 uiKeyBits,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiPKIIndex, 2);
            _os.write(uiKeyBits, 3);
            std::map<string, string> _mStatus;
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                    _p_->value["uiPKIIndex"] = tars::JsonOutput::writeJson(uiPKIIndex);
                    _p_->value["uiKeyBits"] = tars::JsonOutput::writeJson(uiKeyBits);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "generateKeyWithIPK_RSA", 0, _trace_param_, "");
            }
            tars_invoke_async(tars::TARSNORMAL,"generateKeyWithIPK_RSA", _os, context, _mStatus, callback);
        }
        
        tars::Future< KeyManagePrxCallbackPromise::PromisegenerateKeyWithIPK_RSAPtr > promise_async_generateKeyWithIPK_RSA(const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiPKIIndex,tars::UInt32 uiKeyBits,const map<string, string>& context)
        {
            tars::Promise< KeyManagePrxCallbackPromise::PromisegenerateKeyWithIPK_RSAPtr > promise;
            KeyManagePrxCallbackPromisePtr callback = new KeyManagePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiPKIIndex, 2);
            _os.write(uiKeyBits, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"generateKeyWithIPK_RSA", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_generateKeyWithIPK_RSA(KeyManageCoroPrxCallbackPtr callback,const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiPKIIndex,tars::UInt32 uiKeyBits,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiPKIIndex, 2);
            _os.write(uiKeyBits, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"generateKeyWithIPK_RSA", _os, context, _mStatus, callback, true);
        }

        tars::Int32 generateKeyWithKEK(const Mitsurugi::PhSessionHandle & sessionHandle,tars::UInt32 uiKeyBits,tars::UInt32 uiAlgID,tars::UInt32 uiKEKIndex,vector<tars::UInt8> &pucKey,tars::UInt32 &puiKeyLength,Mitsurugi::PhKeyHandle &keyHandle,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiKeyBits, 2);
            _os.write(uiAlgID, 3);
            _os.write(uiKEKIndex, 4);
            _os.write(pucKey, 5);
            _os.write(puiKeyLength, 6);
            _os.write(keyHandle, 7);
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                    _p_->value["uiKeyBits"] = tars::JsonOutput::writeJson(uiKeyBits);
                    _p_->value["uiAlgID"] = tars::JsonOutput::writeJson(uiAlgID);
                    _p_->value["uiKEKIndex"] = tars::JsonOutput::writeJson(uiKEKIndex);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "generateKeyWithKEK", 0, _trace_param_, "");
            }

            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"generateKeyWithKEK", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(pucKey, 5, true);
            _is.read(puiKeyLength, 6, true);
            _is.read(keyHandle, 7, true);
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["pucKey"] = tars::JsonOutput::writeJson(pucKey);
                    _p_->value["puiKeyLength"] = tars::JsonOutput::writeJson(puiKeyLength);
                    _p_->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "generateKeyWithKEK", 0, _trace_param_, "");
            }

            return _ret;
        }

        void async_generateKeyWithKEK(KeyManagePrxCallbackPtr callback,const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiKeyBits,tars::UInt32 uiAlgID,tars::UInt32 uiKEKIndex,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiKeyBits, 2);
            _os.write(uiAlgID, 3);
            _os.write(uiKEKIndex, 4);
            std::map<string, string> _mStatus;
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                    _p_->value["uiKeyBits"] = tars::JsonOutput::writeJson(uiKeyBits);
                    _p_->value["uiAlgID"] = tars::JsonOutput::writeJson(uiAlgID);
                    _p_->value["uiKEKIndex"] = tars::JsonOutput::writeJson(uiKEKIndex);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "generateKeyWithKEK", 0, _trace_param_, "");
            }
            tars_invoke_async(tars::TARSNORMAL,"generateKeyWithKEK", _os, context, _mStatus, callback);
        }
        
        tars::Future< KeyManagePrxCallbackPromise::PromisegenerateKeyWithKEKPtr > promise_async_generateKeyWithKEK(const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiKeyBits,tars::UInt32 uiAlgID,tars::UInt32 uiKEKIndex,const map<string, string>& context)
        {
            tars::Promise< KeyManagePrxCallbackPromise::PromisegenerateKeyWithKEKPtr > promise;
            KeyManagePrxCallbackPromisePtr callback = new KeyManagePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiKeyBits, 2);
            _os.write(uiAlgID, 3);
            _os.write(uiKEKIndex, 4);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"generateKeyWithKEK", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_generateKeyWithKEK(KeyManageCoroPrxCallbackPtr callback,const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiKeyBits,tars::UInt32 uiAlgID,tars::UInt32 uiKEKIndex,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiKeyBits, 2);
            _os.write(uiAlgID, 3);
            _os.write(uiKEKIndex, 4);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"generateKeyWithKEK", _os, context, _mStatus, callback, true);
        }

        tars::Int32 importKey(const Mitsurugi::PhSessionHandle & sessionHandle,const vector<tars::UInt8> & pucKey,tars::UInt32 uiKeyLength,Mitsurugi::PhKeyHandle &keyHandle,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(pucKey, 2);
            _os.write(uiKeyLength, 3);
            _os.write(keyHandle, 4);
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                    _p_->value["pucKey"] = tars::JsonOutput::writeJson(pucKey);
                    _p_->value["uiKeyLength"] = tars::JsonOutput::writeJson(uiKeyLength);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "importKey", 0, _trace_param_, "");
            }

            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"importKey", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(keyHandle, 4, true);
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "importKey", 0, _trace_param_, "");
            }

            return _ret;
        }

        void async_importKey(KeyManagePrxCallbackPtr callback,const Mitsurugi::PhSessionHandle &sessionHandle,const vector<tars::UInt8> &pucKey,tars::UInt32 uiKeyLength,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(pucKey, 2);
            _os.write(uiKeyLength, 3);
            std::map<string, string> _mStatus;
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                    _p_->value["pucKey"] = tars::JsonOutput::writeJson(pucKey);
                    _p_->value["uiKeyLength"] = tars::JsonOutput::writeJson(uiKeyLength);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "importKey", 0, _trace_param_, "");
            }
            tars_invoke_async(tars::TARSNORMAL,"importKey", _os, context, _mStatus, callback);
        }
        
        tars::Future< KeyManagePrxCallbackPromise::PromiseimportKeyPtr > promise_async_importKey(const Mitsurugi::PhSessionHandle &sessionHandle,const vector<tars::UInt8> &pucKey,tars::UInt32 uiKeyLength,const map<string, string>& context)
        {
            tars::Promise< KeyManagePrxCallbackPromise::PromiseimportKeyPtr > promise;
            KeyManagePrxCallbackPromisePtr callback = new KeyManagePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(pucKey, 2);
            _os.write(uiKeyLength, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"importKey", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_importKey(KeyManageCoroPrxCallbackPtr callback,const Mitsurugi::PhSessionHandle &sessionHandle,const vector<tars::UInt8> &pucKey,tars::UInt32 uiKeyLength,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(pucKey, 2);
            _os.write(uiKeyLength, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"importKey", _os, context, _mStatus, callback, true);
        }

        tars::Int32 importKeyWithISK_ECC(const Mitsurugi::PhSessionHandle & sessionHandle,tars::UInt32 uiISKIndex,const Mitsurugi::Tars_ECCCipher & pucKey,Mitsurugi::PhKeyHandle &keyHandle,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiISKIndex, 2);
            _os.write(pucKey, 3);
            _os.write(keyHandle, 4);
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                    _p_->value["uiISKIndex"] = tars::JsonOutput::writeJson(uiISKIndex);
                    _p_->value["pucKey"] = tars::JsonOutput::writeJson(pucKey);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "importKeyWithISK_ECC", 0, _trace_param_, "");
            }

            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"importKeyWithISK_ECC", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(keyHandle, 4, true);
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "importKeyWithISK_ECC", 0, _trace_param_, "");
            }

            return _ret;
        }

        void async_importKeyWithISK_ECC(KeyManagePrxCallbackPtr callback,const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiISKIndex,const Mitsurugi::Tars_ECCCipher &pucKey,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiISKIndex, 2);
            _os.write(pucKey, 3);
            std::map<string, string> _mStatus;
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                    _p_->value["uiISKIndex"] = tars::JsonOutput::writeJson(uiISKIndex);
                    _p_->value["pucKey"] = tars::JsonOutput::writeJson(pucKey);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "importKeyWithISK_ECC", 0, _trace_param_, "");
            }
            tars_invoke_async(tars::TARSNORMAL,"importKeyWithISK_ECC", _os, context, _mStatus, callback);
        }
        
        tars::Future< KeyManagePrxCallbackPromise::PromiseimportKeyWithISK_ECCPtr > promise_async_importKeyWithISK_ECC(const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiISKIndex,const Mitsurugi::Tars_ECCCipher &pucKey,const map<string, string>& context)
        {
            tars::Promise< KeyManagePrxCallbackPromise::PromiseimportKeyWithISK_ECCPtr > promise;
            KeyManagePrxCallbackPromisePtr callback = new KeyManagePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiISKIndex, 2);
            _os.write(pucKey, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"importKeyWithISK_ECC", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_importKeyWithISK_ECC(KeyManageCoroPrxCallbackPtr callback,const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiISKIndex,const Mitsurugi::Tars_ECCCipher &pucKey,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiISKIndex, 2);
            _os.write(pucKey, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"importKeyWithISK_ECC", _os, context, _mStatus, callback, true);
        }

        tars::Int32 importKeyWithISK_RSA(const Mitsurugi::PhSessionHandle & sessionHandle,tars::UInt32 uiISKIndex,const vector<tars::UInt8> & pucKey,tars::UInt32 puiKeyLength,Mitsurugi::PhKeyHandle &keyHandle,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiISKIndex, 2);
            _os.write(pucKey, 3);
            _os.write(puiKeyLength, 4);
            _os.write(keyHandle, 5);
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                    _p_->value["uiISKIndex"] = tars::JsonOutput::writeJson(uiISKIndex);
                    _p_->value["pucKey"] = tars::JsonOutput::writeJson(pucKey);
                    _p_->value["puiKeyLength"] = tars::JsonOutput::writeJson(puiKeyLength);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "importKeyWithISK_RSA", 0, _trace_param_, "");
            }

            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"importKeyWithISK_RSA", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(keyHandle, 5, true);
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "importKeyWithISK_RSA", 0, _trace_param_, "");
            }

            return _ret;
        }

        void async_importKeyWithISK_RSA(KeyManagePrxCallbackPtr callback,const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiISKIndex,const vector<tars::UInt8> &pucKey,tars::UInt32 puiKeyLength,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiISKIndex, 2);
            _os.write(pucKey, 3);
            _os.write(puiKeyLength, 4);
            std::map<string, string> _mStatus;
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                    _p_->value["uiISKIndex"] = tars::JsonOutput::writeJson(uiISKIndex);
                    _p_->value["pucKey"] = tars::JsonOutput::writeJson(pucKey);
                    _p_->value["puiKeyLength"] = tars::JsonOutput::writeJson(puiKeyLength);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "importKeyWithISK_RSA", 0, _trace_param_, "");
            }
            tars_invoke_async(tars::TARSNORMAL,"importKeyWithISK_RSA", _os, context, _mStatus, callback);
        }
        
        tars::Future< KeyManagePrxCallbackPromise::PromiseimportKeyWithISK_RSAPtr > promise_async_importKeyWithISK_RSA(const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiISKIndex,const vector<tars::UInt8> &pucKey,tars::UInt32 puiKeyLength,const map<string, string>& context)
        {
            tars::Promise< KeyManagePrxCallbackPromise::PromiseimportKeyWithISK_RSAPtr > promise;
            KeyManagePrxCallbackPromisePtr callback = new KeyManagePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiISKIndex, 2);
            _os.write(pucKey, 3);
            _os.write(puiKeyLength, 4);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"importKeyWithISK_RSA", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_importKeyWithISK_RSA(KeyManageCoroPrxCallbackPtr callback,const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiISKIndex,const vector<tars::UInt8> &pucKey,tars::UInt32 puiKeyLength,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiISKIndex, 2);
            _os.write(pucKey, 3);
            _os.write(puiKeyLength, 4);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"importKeyWithISK_RSA", _os, context, _mStatus, callback, true);
        }

        tars::Int32 importKeyWithKEK(const Mitsurugi::PhSessionHandle & sessionHandle,tars::UInt32 uiAlgID,tars::UInt32 uiKEKIndex,const vector<tars::UInt8> & pucKey,tars::UInt32 puiKeyLength,Mitsurugi::PhKeyHandle &keyHandle,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiAlgID, 2);
            _os.write(uiKEKIndex, 3);
            _os.write(pucKey, 4);
            _os.write(puiKeyLength, 5);
            _os.write(keyHandle, 6);
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                    _p_->value["uiAlgID"] = tars::JsonOutput::writeJson(uiAlgID);
                    _p_->value["uiKEKIndex"] = tars::JsonOutput::writeJson(uiKEKIndex);
                    _p_->value["pucKey"] = tars::JsonOutput::writeJson(pucKey);
                    _p_->value["puiKeyLength"] = tars::JsonOutput::writeJson(puiKeyLength);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "importKeyWithKEK", 0, _trace_param_, "");
            }

            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"importKeyWithKEK", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(keyHandle, 6, true);
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "importKeyWithKEK", 0, _trace_param_, "");
            }

            return _ret;
        }

        void async_importKeyWithKEK(KeyManagePrxCallbackPtr callback,const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiAlgID,tars::UInt32 uiKEKIndex,const vector<tars::UInt8> &pucKey,tars::UInt32 puiKeyLength,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiAlgID, 2);
            _os.write(uiKEKIndex, 3);
            _os.write(pucKey, 4);
            _os.write(puiKeyLength, 5);
            std::map<string, string> _mStatus;
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                    _p_->value["uiAlgID"] = tars::JsonOutput::writeJson(uiAlgID);
                    _p_->value["uiKEKIndex"] = tars::JsonOutput::writeJson(uiKEKIndex);
                    _p_->value["pucKey"] = tars::JsonOutput::writeJson(pucKey);
                    _p_->value["puiKeyLength"] = tars::JsonOutput::writeJson(puiKeyLength);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, ServerConfig::Application + "." + ServerConfig::ServerName, tars_name(), "importKeyWithKEK", 0, _trace_param_, "");
            }
            tars_invoke_async(tars::TARSNORMAL,"importKeyWithKEK", _os, context, _mStatus, callback);
        }
        
        tars::Future< KeyManagePrxCallbackPromise::PromiseimportKeyWithKEKPtr > promise_async_importKeyWithKEK(const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiAlgID,tars::UInt32 uiKEKIndex,const vector<tars::UInt8> &pucKey,tars::UInt32 puiKeyLength,const map<string, string>& context)
        {
            tars::Promise< KeyManagePrxCallbackPromise::PromiseimportKeyWithKEKPtr > promise;
            KeyManagePrxCallbackPromisePtr callback = new KeyManagePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiAlgID, 2);
            _os.write(uiKEKIndex, 3);
            _os.write(pucKey, 4);
            _os.write(puiKeyLength, 5);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"importKeyWithKEK", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_importKeyWithKEK(KeyManageCoroPrxCallbackPtr callback,const Mitsurugi::PhSessionHandle &sessionHandle,tars::UInt32 uiAlgID,tars::UInt32 uiKEKIndex,const vector<tars::UInt8> &pucKey,tars::UInt32 puiKeyLength,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sessionHandle, 1);
            _os.write(uiAlgID, 2);
            _os.write(uiKEKIndex, 3);
            _os.write(pucKey, 4);
            _os.write(puiKeyLength, 5);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"importKeyWithKEK", _os, context, _mStatus, callback, true);
        }

        KeyManageProxy* tars_hash(uint32_t key)
        {
            return (KeyManageProxy*)ServantProxy::tars_hash(key);
        }

        KeyManageProxy* tars_consistent_hash(uint32_t key)
        {
            return (KeyManageProxy*)ServantProxy::tars_consistent_hash(key);
        }

        KeyManageProxy* tars_open_trace(bool traceParam = false)
        {
            return (KeyManageProxy*)ServantProxy::tars_open_trace(traceParam);
        }

        KeyManageProxy* tars_set_timeout(int msecond)
        {
            return (KeyManageProxy*)ServantProxy::tars_set_timeout(msecond);
        }

        static const char* tars_prxname() { return "KeyManageProxy"; }
    };
    typedef tars::TC_AutoPtr<KeyManageProxy> KeyManagePrx;

    /* servant for server */
    class KeyManage : public tars::Servant
    {
    public:
        virtual ~KeyManage(){}
        virtual tars::Int32 destroyKey(const Mitsurugi::PhSessionHandle & sessionHandle,const Mitsurugi::PhKeyHandle & keyHandle,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 destroyKey(Mitsurugi::PhSessionHandle && sessionHandle,Mitsurugi::PhKeyHandle && keyHandle,tars::TarsCurrentPtr _current_) 
        { return destroyKey(sessionHandle, keyHandle, _current_); }
        static void async_response_destroyKey(tars::TarsCurrentPtr _current_, tars::Int32 _ret)
        {
            size_t _rsp_len_ = 0;
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
                _rsp_len_ = sTupResponseBuffer.size();
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
                _rsp_len_ = sJsonResponseBuffer.size();
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _rsp_len_ = _os.getLength();
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
            if (_current_->isTraced())
            {
                string _trace_param_;
                int _trace_param_flag_ = ServantProxyThreadData::needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _current_->getTraceKey(), _rsp_len_);
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_current_->getTraceKey(), TRACE_ANNOTATION_SS, "", ServerConfig::Application + "." + ServerConfig::ServerName, "destroyKey", 0, _trace_param_, "");
            }

        }
        static void async_response_push_destroyKey(tars::CurrentPtr _current_, tars::Int32 _ret, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"destroyKey", _os, _context);
            }
        }

        virtual tars::Int32 exchangeDigitEncelopeBaseOnECC(const Mitsurugi::PhSessionHandle & sessionHandle,tars::UInt32 uiKeyIndex,tars::UInt32 uiAlgID,const Mitsurugi::Tars_ECCrefPublicKey & pucPublicKey,const Mitsurugi::Tars_ECCCipher & pucEncDataIn,Mitsurugi::Tars_ECCCipher &pucEncDataOut,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 exchangeDigitEncelopeBaseOnECC(Mitsurugi::PhSessionHandle && sessionHandle,tars::UInt32 uiKeyIndex,tars::UInt32 uiAlgID,Mitsurugi::Tars_ECCrefPublicKey && pucPublicKey,Mitsurugi::Tars_ECCCipher && pucEncDataIn,Mitsurugi::Tars_ECCCipher &pucEncDataOut,tars::TarsCurrentPtr _current_) 
        { return exchangeDigitEncelopeBaseOnECC(sessionHandle, uiKeyIndex, uiAlgID, pucPublicKey, pucEncDataIn, pucEncDataOut, _current_); }
        static void async_response_exchangeDigitEncelopeBaseOnECC(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const Mitsurugi::Tars_ECCCipher &pucEncDataOut)
        {
            size_t _rsp_len_ = 0;
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("pucEncDataOut", pucEncDataOut);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
                _rsp_len_ = sTupResponseBuffer.size();
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["pucEncDataOut"] = tars::JsonOutput::writeJson(pucEncDataOut);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
                _rsp_len_ = sJsonResponseBuffer.size();
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(pucEncDataOut, 6);

                _rsp_len_ = _os.getLength();
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
            if (_current_->isTraced())
            {
                string _trace_param_;
                int _trace_param_flag_ = ServantProxyThreadData::needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _current_->getTraceKey(), _rsp_len_);
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["pucEncDataOut"] = tars::JsonOutput::writeJson(pucEncDataOut);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_current_->getTraceKey(), TRACE_ANNOTATION_SS, "", ServerConfig::Application + "." + ServerConfig::ServerName, "exchangeDigitEncelopeBaseOnECC", 0, _trace_param_, "");
            }

        }
        static void async_response_push_exchangeDigitEncelopeBaseOnECC(tars::CurrentPtr _current_, tars::Int32 _ret, const Mitsurugi::Tars_ECCCipher &pucEncDataOut, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(pucEncDataOut, 6);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"exchangeDigitEncelopeBaseOnECC", _os, _context);
            }
        }

        virtual tars::Int32 exchangeDigitEnvelopeBaseOnRSA(const Mitsurugi::PhSessionHandle & sessionHandle,tars::UInt32 uiKeyIndex,const Mitsurugi::Tars_RSArefPublicKey & pucPublicKey,const vector<tars::UInt8> & pucDEInput,tars::UInt32 uiDELength,vector<tars::UInt8> &pucDEOutput,tars::UInt32 &puiDELength,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 exchangeDigitEnvelopeBaseOnRSA(Mitsurugi::PhSessionHandle && sessionHandle,tars::UInt32 uiKeyIndex,Mitsurugi::Tars_RSArefPublicKey && pucPublicKey,vector<tars::UInt8> && pucDEInput,tars::UInt32 uiDELength,vector<tars::UInt8> &pucDEOutput,tars::UInt32 &puiDELength,tars::TarsCurrentPtr _current_) 
        { return exchangeDigitEnvelopeBaseOnRSA(sessionHandle, uiKeyIndex, pucPublicKey, pucDEInput, uiDELength, pucDEOutput, puiDELength, _current_); }
        static void async_response_exchangeDigitEnvelopeBaseOnRSA(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const vector<tars::UInt8> &pucDEOutput, tars::UInt32 puiDELength)
        {
            size_t _rsp_len_ = 0;
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("pucDEOutput", pucDEOutput);
                _tarsAttr_.put("puiDELength", puiDELength);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
                _rsp_len_ = sTupResponseBuffer.size();
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["pucDEOutput"] = tars::JsonOutput::writeJson(pucDEOutput);
                _p->value["puiDELength"] = tars::JsonOutput::writeJson(puiDELength);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
                _rsp_len_ = sJsonResponseBuffer.size();
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(pucDEOutput, 6);

                _os.write(puiDELength, 7);

                _rsp_len_ = _os.getLength();
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
            if (_current_->isTraced())
            {
                string _trace_param_;
                int _trace_param_flag_ = ServantProxyThreadData::needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _current_->getTraceKey(), _rsp_len_);
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["pucDEOutput"] = tars::JsonOutput::writeJson(pucDEOutput);
                    _p_->value["puiDELength"] = tars::JsonOutput::writeJson(puiDELength);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_current_->getTraceKey(), TRACE_ANNOTATION_SS, "", ServerConfig::Application + "." + ServerConfig::ServerName, "exchangeDigitEnvelopeBaseOnRSA", 0, _trace_param_, "");
            }

        }
        static void async_response_push_exchangeDigitEnvelopeBaseOnRSA(tars::CurrentPtr _current_, tars::Int32 _ret, const vector<tars::UInt8> &pucDEOutput, tars::UInt32 puiDELength, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(pucDEOutput, 6);

                _os.write(puiDELength, 7);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"exchangeDigitEnvelopeBaseOnRSA", _os, _context);
            }
        }

        virtual tars::Int32 exportEncPublicKey_ECC(const Mitsurugi::PhSessionHandle & sessionHandle,tars::UInt32 uiKeyIndex,Mitsurugi::Tars_ECCrefPublicKey &pucPublicKey,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 exportEncPublicKey_ECC(Mitsurugi::PhSessionHandle && sessionHandle,tars::UInt32 uiKeyIndex,Mitsurugi::Tars_ECCrefPublicKey &pucPublicKey,tars::TarsCurrentPtr _current_) 
        { return exportEncPublicKey_ECC(sessionHandle, uiKeyIndex, pucPublicKey, _current_); }
        static void async_response_exportEncPublicKey_ECC(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const Mitsurugi::Tars_ECCrefPublicKey &pucPublicKey)
        {
            size_t _rsp_len_ = 0;
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("pucPublicKey", pucPublicKey);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
                _rsp_len_ = sTupResponseBuffer.size();
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["pucPublicKey"] = tars::JsonOutput::writeJson(pucPublicKey);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
                _rsp_len_ = sJsonResponseBuffer.size();
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(pucPublicKey, 3);

                _rsp_len_ = _os.getLength();
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
            if (_current_->isTraced())
            {
                string _trace_param_;
                int _trace_param_flag_ = ServantProxyThreadData::needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _current_->getTraceKey(), _rsp_len_);
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["pucPublicKey"] = tars::JsonOutput::writeJson(pucPublicKey);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_current_->getTraceKey(), TRACE_ANNOTATION_SS, "", ServerConfig::Application + "." + ServerConfig::ServerName, "exportEncPublicKey_ECC", 0, _trace_param_, "");
            }

        }
        static void async_response_push_exportEncPublicKey_ECC(tars::CurrentPtr _current_, tars::Int32 _ret, const Mitsurugi::Tars_ECCrefPublicKey &pucPublicKey, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(pucPublicKey, 3);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"exportEncPublicKey_ECC", _os, _context);
            }
        }

        virtual tars::Int32 exportEncPublicKey_RSA(const Mitsurugi::PhSessionHandle & sessionHandle,tars::UInt32 uiKeyIndex,Mitsurugi::Tars_RSArefPublicKey &pucPublicKey,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 exportEncPublicKey_RSA(Mitsurugi::PhSessionHandle && sessionHandle,tars::UInt32 uiKeyIndex,Mitsurugi::Tars_RSArefPublicKey &pucPublicKey,tars::TarsCurrentPtr _current_) 
        { return exportEncPublicKey_RSA(sessionHandle, uiKeyIndex, pucPublicKey, _current_); }
        static void async_response_exportEncPublicKey_RSA(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const Mitsurugi::Tars_RSArefPublicKey &pucPublicKey)
        {
            size_t _rsp_len_ = 0;
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("pucPublicKey", pucPublicKey);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
                _rsp_len_ = sTupResponseBuffer.size();
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["pucPublicKey"] = tars::JsonOutput::writeJson(pucPublicKey);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
                _rsp_len_ = sJsonResponseBuffer.size();
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(pucPublicKey, 3);

                _rsp_len_ = _os.getLength();
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
            if (_current_->isTraced())
            {
                string _trace_param_;
                int _trace_param_flag_ = ServantProxyThreadData::needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _current_->getTraceKey(), _rsp_len_);
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["pucPublicKey"] = tars::JsonOutput::writeJson(pucPublicKey);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_current_->getTraceKey(), TRACE_ANNOTATION_SS, "", ServerConfig::Application + "." + ServerConfig::ServerName, "exportEncPublicKey_RSA", 0, _trace_param_, "");
            }

        }
        static void async_response_push_exportEncPublicKey_RSA(tars::CurrentPtr _current_, tars::Int32 _ret, const Mitsurugi::Tars_RSArefPublicKey &pucPublicKey, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(pucPublicKey, 3);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"exportEncPublicKey_RSA", _os, _context);
            }
        }

        virtual tars::Int32 exportSignPublicKey_ECC(const Mitsurugi::PhSessionHandle & sessionHandle,tars::UInt32 uiKeyIndex,Mitsurugi::Tars_ECCrefPublicKey &pucPublicKey,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 exportSignPublicKey_ECC(Mitsurugi::PhSessionHandle && sessionHandle,tars::UInt32 uiKeyIndex,Mitsurugi::Tars_ECCrefPublicKey &pucPublicKey,tars::TarsCurrentPtr _current_) 
        { return exportSignPublicKey_ECC(sessionHandle, uiKeyIndex, pucPublicKey, _current_); }
        static void async_response_exportSignPublicKey_ECC(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const Mitsurugi::Tars_ECCrefPublicKey &pucPublicKey)
        {
            size_t _rsp_len_ = 0;
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("pucPublicKey", pucPublicKey);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
                _rsp_len_ = sTupResponseBuffer.size();
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["pucPublicKey"] = tars::JsonOutput::writeJson(pucPublicKey);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
                _rsp_len_ = sJsonResponseBuffer.size();
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(pucPublicKey, 3);

                _rsp_len_ = _os.getLength();
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
            if (_current_->isTraced())
            {
                string _trace_param_;
                int _trace_param_flag_ = ServantProxyThreadData::needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _current_->getTraceKey(), _rsp_len_);
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["pucPublicKey"] = tars::JsonOutput::writeJson(pucPublicKey);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_current_->getTraceKey(), TRACE_ANNOTATION_SS, "", ServerConfig::Application + "." + ServerConfig::ServerName, "exportSignPublicKey_ECC", 0, _trace_param_, "");
            }

        }
        static void async_response_push_exportSignPublicKey_ECC(tars::CurrentPtr _current_, tars::Int32 _ret, const Mitsurugi::Tars_ECCrefPublicKey &pucPublicKey, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(pucPublicKey, 3);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"exportSignPublicKey_ECC", _os, _context);
            }
        }

        virtual tars::Int32 exportSignPublicKey_RSA(const Mitsurugi::PhSessionHandle & sessionHandle,tars::UInt32 uiKeyIndex,Mitsurugi::Tars_RSArefPublicKey &pucPublicKey,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 exportSignPublicKey_RSA(Mitsurugi::PhSessionHandle && sessionHandle,tars::UInt32 uiKeyIndex,Mitsurugi::Tars_RSArefPublicKey &pucPublicKey,tars::TarsCurrentPtr _current_) 
        { return exportSignPublicKey_RSA(sessionHandle, uiKeyIndex, pucPublicKey, _current_); }
        static void async_response_exportSignPublicKey_RSA(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const Mitsurugi::Tars_RSArefPublicKey &pucPublicKey)
        {
            size_t _rsp_len_ = 0;
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("pucPublicKey", pucPublicKey);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
                _rsp_len_ = sTupResponseBuffer.size();
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["pucPublicKey"] = tars::JsonOutput::writeJson(pucPublicKey);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
                _rsp_len_ = sJsonResponseBuffer.size();
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(pucPublicKey, 3);

                _rsp_len_ = _os.getLength();
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
            if (_current_->isTraced())
            {
                string _trace_param_;
                int _trace_param_flag_ = ServantProxyThreadData::needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _current_->getTraceKey(), _rsp_len_);
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["pucPublicKey"] = tars::JsonOutput::writeJson(pucPublicKey);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_current_->getTraceKey(), TRACE_ANNOTATION_SS, "", ServerConfig::Application + "." + ServerConfig::ServerName, "exportSignPublicKey_RSA", 0, _trace_param_, "");
            }

        }
        static void async_response_push_exportSignPublicKey_RSA(tars::CurrentPtr _current_, tars::Int32 _ret, const Mitsurugi::Tars_RSArefPublicKey &pucPublicKey, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(pucPublicKey, 3);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"exportSignPublicKey_RSA", _os, _context);
            }
        }

        virtual tars::Int32 generateAgreementDataAndKeyWithECC(const Mitsurugi::PhSessionHandle & sessionHandle,tars::UInt32 uiISKIndex,tars::UInt32 uiKeyBits,const vector<tars::UInt8> & pucResponseID,tars::UInt32 uiResponseIDLength,const vector<tars::UInt8> & pucSponsorID,tars::UInt32 uiSponsorIDLength,const Mitsurugi::Tars_ECCrefPublicKey & pucSponsorPublicKey,const Mitsurugi::Tars_ECCrefPublicKey & pucSponsorTmpPublicKey,Mitsurugi::Tars_ECCrefPublicKey &pucResponsePublicKey,Mitsurugi::Tars_ECCrefPublicKey &pucResponseTmpPublicKey,Mitsurugi::PhKeyHandle &keyHandle,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 generateAgreementDataAndKeyWithECC(Mitsurugi::PhSessionHandle && sessionHandle,tars::UInt32 uiISKIndex,tars::UInt32 uiKeyBits,vector<tars::UInt8> && pucResponseID,tars::UInt32 uiResponseIDLength,vector<tars::UInt8> && pucSponsorID,tars::UInt32 uiSponsorIDLength,Mitsurugi::Tars_ECCrefPublicKey && pucSponsorPublicKey,Mitsurugi::Tars_ECCrefPublicKey && pucSponsorTmpPublicKey,Mitsurugi::Tars_ECCrefPublicKey &pucResponsePublicKey,Mitsurugi::Tars_ECCrefPublicKey &pucResponseTmpPublicKey,Mitsurugi::PhKeyHandle &keyHandle,tars::TarsCurrentPtr _current_) 
        { return generateAgreementDataAndKeyWithECC(sessionHandle, uiISKIndex, uiKeyBits, pucResponseID, uiResponseIDLength, pucSponsorID, uiSponsorIDLength, pucSponsorPublicKey, pucSponsorTmpPublicKey, pucResponsePublicKey, pucResponseTmpPublicKey, keyHandle, _current_); }
        static void async_response_generateAgreementDataAndKeyWithECC(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const Mitsurugi::Tars_ECCrefPublicKey &pucResponsePublicKey, const Mitsurugi::Tars_ECCrefPublicKey &pucResponseTmpPublicKey, const Mitsurugi::PhKeyHandle &keyHandle)
        {
            size_t _rsp_len_ = 0;
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("pucResponsePublicKey", pucResponsePublicKey);
                _tarsAttr_.put("pucResponseTmpPublicKey", pucResponseTmpPublicKey);
                _tarsAttr_.put("keyHandle", keyHandle);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
                _rsp_len_ = sTupResponseBuffer.size();
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["pucResponsePublicKey"] = tars::JsonOutput::writeJson(pucResponsePublicKey);
                _p->value["pucResponseTmpPublicKey"] = tars::JsonOutput::writeJson(pucResponseTmpPublicKey);
                _p->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
                _rsp_len_ = sJsonResponseBuffer.size();
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(pucResponsePublicKey, 10);

                _os.write(pucResponseTmpPublicKey, 11);

                _os.write(keyHandle, 12);

                _rsp_len_ = _os.getLength();
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
            if (_current_->isTraced())
            {
                string _trace_param_;
                int _trace_param_flag_ = ServantProxyThreadData::needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _current_->getTraceKey(), _rsp_len_);
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["pucResponsePublicKey"] = tars::JsonOutput::writeJson(pucResponsePublicKey);
                    _p_->value["pucResponseTmpPublicKey"] = tars::JsonOutput::writeJson(pucResponseTmpPublicKey);
                    _p_->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_current_->getTraceKey(), TRACE_ANNOTATION_SS, "", ServerConfig::Application + "." + ServerConfig::ServerName, "generateAgreementDataAndKeyWithECC", 0, _trace_param_, "");
            }

        }
        static void async_response_push_generateAgreementDataAndKeyWithECC(tars::CurrentPtr _current_, tars::Int32 _ret, const Mitsurugi::Tars_ECCrefPublicKey &pucResponsePublicKey, const Mitsurugi::Tars_ECCrefPublicKey &pucResponseTmpPublicKey, const Mitsurugi::PhKeyHandle &keyHandle, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(pucResponsePublicKey, 10);

                _os.write(pucResponseTmpPublicKey, 11);

                _os.write(keyHandle, 12);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"generateAgreementDataAndKeyWithECC", _os, _context);
            }
        }

        virtual tars::Int32 generateAgreementDataWithECC(const Mitsurugi::PhSessionHandle & sessionHandle,tars::UInt32 uiISKIndex,tars::UInt32 uiKeyBits,const vector<tars::UInt8> & pucSponsorID,tars::UInt32 uiSponsorIDLength,Mitsurugi::Tars_ECCrefPublicKey &pucSponsorPublicKey,Mitsurugi::Tars_ECCrefPublicKey &pucSponsorTmpPublicKey,Mitsurugi::PhAgreementHandle &agreementHandle,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 generateAgreementDataWithECC(Mitsurugi::PhSessionHandle && sessionHandle,tars::UInt32 uiISKIndex,tars::UInt32 uiKeyBits,vector<tars::UInt8> && pucSponsorID,tars::UInt32 uiSponsorIDLength,Mitsurugi::Tars_ECCrefPublicKey &pucSponsorPublicKey,Mitsurugi::Tars_ECCrefPublicKey &pucSponsorTmpPublicKey,Mitsurugi::PhAgreementHandle &agreementHandle,tars::TarsCurrentPtr _current_) 
        { return generateAgreementDataWithECC(sessionHandle, uiISKIndex, uiKeyBits, pucSponsorID, uiSponsorIDLength, pucSponsorPublicKey, pucSponsorTmpPublicKey, agreementHandle, _current_); }
        static void async_response_generateAgreementDataWithECC(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const Mitsurugi::Tars_ECCrefPublicKey &pucSponsorPublicKey, const Mitsurugi::Tars_ECCrefPublicKey &pucSponsorTmpPublicKey, const Mitsurugi::PhAgreementHandle &agreementHandle)
        {
            size_t _rsp_len_ = 0;
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("pucSponsorPublicKey", pucSponsorPublicKey);
                _tarsAttr_.put("pucSponsorTmpPublicKey", pucSponsorTmpPublicKey);
                _tarsAttr_.put("agreementHandle", agreementHandle);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
                _rsp_len_ = sTupResponseBuffer.size();
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["pucSponsorPublicKey"] = tars::JsonOutput::writeJson(pucSponsorPublicKey);
                _p->value["pucSponsorTmpPublicKey"] = tars::JsonOutput::writeJson(pucSponsorTmpPublicKey);
                _p->value["agreementHandle"] = tars::JsonOutput::writeJson(agreementHandle);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
                _rsp_len_ = sJsonResponseBuffer.size();
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(pucSponsorPublicKey, 6);

                _os.write(pucSponsorTmpPublicKey, 7);

                _os.write(agreementHandle, 8);

                _rsp_len_ = _os.getLength();
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
            if (_current_->isTraced())
            {
                string _trace_param_;
                int _trace_param_flag_ = ServantProxyThreadData::needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _current_->getTraceKey(), _rsp_len_);
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["pucSponsorPublicKey"] = tars::JsonOutput::writeJson(pucSponsorPublicKey);
                    _p_->value["pucSponsorTmpPublicKey"] = tars::JsonOutput::writeJson(pucSponsorTmpPublicKey);
                    _p_->value["agreementHandle"] = tars::JsonOutput::writeJson(agreementHandle);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_current_->getTraceKey(), TRACE_ANNOTATION_SS, "", ServerConfig::Application + "." + ServerConfig::ServerName, "generateAgreementDataWithECC", 0, _trace_param_, "");
            }

        }
        static void async_response_push_generateAgreementDataWithECC(tars::CurrentPtr _current_, tars::Int32 _ret, const Mitsurugi::Tars_ECCrefPublicKey &pucSponsorPublicKey, const Mitsurugi::Tars_ECCrefPublicKey &pucSponsorTmpPublicKey, const Mitsurugi::PhAgreementHandle &agreementHandle, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(pucSponsorPublicKey, 6);

                _os.write(pucSponsorTmpPublicKey, 7);

                _os.write(agreementHandle, 8);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"generateAgreementDataWithECC", _os, _context);
            }
        }

        virtual tars::Int32 generateKeyPair_ECC(const Mitsurugi::PhSessionHandle & sessionHandle,tars::UInt32 uiAlgID,tars::UInt32 uiKeyBits,Mitsurugi::Tars_ECCrefPublicKey &pucPublicKey,Mitsurugi::Tars_ECCrefPrivateKey &pucPrivateKey,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 generateKeyPair_ECC(Mitsurugi::PhSessionHandle && sessionHandle,tars::UInt32 uiAlgID,tars::UInt32 uiKeyBits,Mitsurugi::Tars_ECCrefPublicKey &pucPublicKey,Mitsurugi::Tars_ECCrefPrivateKey &pucPrivateKey,tars::TarsCurrentPtr _current_) 
        { return generateKeyPair_ECC(sessionHandle, uiAlgID, uiKeyBits, pucPublicKey, pucPrivateKey, _current_); }
        static void async_response_generateKeyPair_ECC(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const Mitsurugi::Tars_ECCrefPublicKey &pucPublicKey, const Mitsurugi::Tars_ECCrefPrivateKey &pucPrivateKey)
        {
            size_t _rsp_len_ = 0;
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("pucPublicKey", pucPublicKey);
                _tarsAttr_.put("pucPrivateKey", pucPrivateKey);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
                _rsp_len_ = sTupResponseBuffer.size();
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["pucPublicKey"] = tars::JsonOutput::writeJson(pucPublicKey);
                _p->value["pucPrivateKey"] = tars::JsonOutput::writeJson(pucPrivateKey);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
                _rsp_len_ = sJsonResponseBuffer.size();
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(pucPublicKey, 4);

                _os.write(pucPrivateKey, 5);

                _rsp_len_ = _os.getLength();
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
            if (_current_->isTraced())
            {
                string _trace_param_;
                int _trace_param_flag_ = ServantProxyThreadData::needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _current_->getTraceKey(), _rsp_len_);
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["pucPublicKey"] = tars::JsonOutput::writeJson(pucPublicKey);
                    _p_->value["pucPrivateKey"] = tars::JsonOutput::writeJson(pucPrivateKey);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_current_->getTraceKey(), TRACE_ANNOTATION_SS, "", ServerConfig::Application + "." + ServerConfig::ServerName, "generateKeyPair_ECC", 0, _trace_param_, "");
            }

        }
        static void async_response_push_generateKeyPair_ECC(tars::CurrentPtr _current_, tars::Int32 _ret, const Mitsurugi::Tars_ECCrefPublicKey &pucPublicKey, const Mitsurugi::Tars_ECCrefPrivateKey &pucPrivateKey, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(pucPublicKey, 4);

                _os.write(pucPrivateKey, 5);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"generateKeyPair_ECC", _os, _context);
            }
        }

        virtual tars::Int32 generateKeyPair_RSA(const Mitsurugi::PhSessionHandle & sessionHandle,tars::UInt32 uiKeyBits,Mitsurugi::Tars_RSArefPublicKey &pucPublicKey,Mitsurugi::Tars_RSArefPrivateKey &pucPrivateKey,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 generateKeyPair_RSA(Mitsurugi::PhSessionHandle && sessionHandle,tars::UInt32 uiKeyBits,Mitsurugi::Tars_RSArefPublicKey &pucPublicKey,Mitsurugi::Tars_RSArefPrivateKey &pucPrivateKey,tars::TarsCurrentPtr _current_) 
        { return generateKeyPair_RSA(sessionHandle, uiKeyBits, pucPublicKey, pucPrivateKey, _current_); }
        static void async_response_generateKeyPair_RSA(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const Mitsurugi::Tars_RSArefPublicKey &pucPublicKey, const Mitsurugi::Tars_RSArefPrivateKey &pucPrivateKey)
        {
            size_t _rsp_len_ = 0;
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("pucPublicKey", pucPublicKey);
                _tarsAttr_.put("pucPrivateKey", pucPrivateKey);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
                _rsp_len_ = sTupResponseBuffer.size();
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["pucPublicKey"] = tars::JsonOutput::writeJson(pucPublicKey);
                _p->value["pucPrivateKey"] = tars::JsonOutput::writeJson(pucPrivateKey);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
                _rsp_len_ = sJsonResponseBuffer.size();
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(pucPublicKey, 3);

                _os.write(pucPrivateKey, 4);

                _rsp_len_ = _os.getLength();
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
            if (_current_->isTraced())
            {
                string _trace_param_;
                int _trace_param_flag_ = ServantProxyThreadData::needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _current_->getTraceKey(), _rsp_len_);
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["pucPublicKey"] = tars::JsonOutput::writeJson(pucPublicKey);
                    _p_->value["pucPrivateKey"] = tars::JsonOutput::writeJson(pucPrivateKey);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_current_->getTraceKey(), TRACE_ANNOTATION_SS, "", ServerConfig::Application + "." + ServerConfig::ServerName, "generateKeyPair_RSA", 0, _trace_param_, "");
            }

        }
        static void async_response_push_generateKeyPair_RSA(tars::CurrentPtr _current_, tars::Int32 _ret, const Mitsurugi::Tars_RSArefPublicKey &pucPublicKey, const Mitsurugi::Tars_RSArefPrivateKey &pucPrivateKey, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(pucPublicKey, 3);

                _os.write(pucPrivateKey, 4);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"generateKeyPair_RSA", _os, _context);
            }
        }

        virtual tars::Int32 generateKeyWithECC(const Mitsurugi::PhSessionHandle & sessionHandle,const vector<tars::UInt8> & pucResponseID,tars::UInt32 uiResponseIDLength,const Mitsurugi::Tars_ECCrefPublicKey & pucResponsePublicKey,const Mitsurugi::Tars_ECCrefPublicKey & pucResponseTmpPublicKey,const Mitsurugi::PhAgreementHandle & agreementHandle,Mitsurugi::PhKeyHandle &keyHandle,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 generateKeyWithECC(Mitsurugi::PhSessionHandle && sessionHandle,vector<tars::UInt8> && pucResponseID,tars::UInt32 uiResponseIDLength,Mitsurugi::Tars_ECCrefPublicKey && pucResponsePublicKey,Mitsurugi::Tars_ECCrefPublicKey && pucResponseTmpPublicKey,Mitsurugi::PhAgreementHandle && agreementHandle,Mitsurugi::PhKeyHandle &keyHandle,tars::TarsCurrentPtr _current_) 
        { return generateKeyWithECC(sessionHandle, pucResponseID, uiResponseIDLength, pucResponsePublicKey, pucResponseTmpPublicKey, agreementHandle, keyHandle, _current_); }
        static void async_response_generateKeyWithECC(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const Mitsurugi::PhKeyHandle &keyHandle)
        {
            size_t _rsp_len_ = 0;
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("keyHandle", keyHandle);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
                _rsp_len_ = sTupResponseBuffer.size();
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
                _rsp_len_ = sJsonResponseBuffer.size();
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(keyHandle, 7);

                _rsp_len_ = _os.getLength();
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
            if (_current_->isTraced())
            {
                string _trace_param_;
                int _trace_param_flag_ = ServantProxyThreadData::needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _current_->getTraceKey(), _rsp_len_);
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_current_->getTraceKey(), TRACE_ANNOTATION_SS, "", ServerConfig::Application + "." + ServerConfig::ServerName, "generateKeyWithECC", 0, _trace_param_, "");
            }

        }
        static void async_response_push_generateKeyWithECC(tars::CurrentPtr _current_, tars::Int32 _ret, const Mitsurugi::PhKeyHandle &keyHandle, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(keyHandle, 7);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"generateKeyWithECC", _os, _context);
            }
        }

        virtual tars::Int32 generateKeyWithEPK_ECC(const Mitsurugi::PhSessionHandle & sessionHandle,tars::UInt32 uiKeyBits,tars::UInt32 uiAlgID,const Mitsurugi::Tars_ECCrefPublicKey & pucPublicKey,Mitsurugi::Tars_ECCCipher &pucKey,Mitsurugi::PhKeyHandle &keyHandle,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 generateKeyWithEPK_ECC(Mitsurugi::PhSessionHandle && sessionHandle,tars::UInt32 uiKeyBits,tars::UInt32 uiAlgID,Mitsurugi::Tars_ECCrefPublicKey && pucPublicKey,Mitsurugi::Tars_ECCCipher &pucKey,Mitsurugi::PhKeyHandle &keyHandle,tars::TarsCurrentPtr _current_) 
        { return generateKeyWithEPK_ECC(sessionHandle, uiKeyBits, uiAlgID, pucPublicKey, pucKey, keyHandle, _current_); }
        static void async_response_generateKeyWithEPK_ECC(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const Mitsurugi::Tars_ECCCipher &pucKey, const Mitsurugi::PhKeyHandle &keyHandle)
        {
            size_t _rsp_len_ = 0;
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("pucKey", pucKey);
                _tarsAttr_.put("keyHandle", keyHandle);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
                _rsp_len_ = sTupResponseBuffer.size();
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["pucKey"] = tars::JsonOutput::writeJson(pucKey);
                _p->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
                _rsp_len_ = sJsonResponseBuffer.size();
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(pucKey, 5);

                _os.write(keyHandle, 6);

                _rsp_len_ = _os.getLength();
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
            if (_current_->isTraced())
            {
                string _trace_param_;
                int _trace_param_flag_ = ServantProxyThreadData::needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _current_->getTraceKey(), _rsp_len_);
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["pucKey"] = tars::JsonOutput::writeJson(pucKey);
                    _p_->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_current_->getTraceKey(), TRACE_ANNOTATION_SS, "", ServerConfig::Application + "." + ServerConfig::ServerName, "generateKeyWithEPK_ECC", 0, _trace_param_, "");
            }

        }
        static void async_response_push_generateKeyWithEPK_ECC(tars::CurrentPtr _current_, tars::Int32 _ret, const Mitsurugi::Tars_ECCCipher &pucKey, const Mitsurugi::PhKeyHandle &keyHandle, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(pucKey, 5);

                _os.write(keyHandle, 6);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"generateKeyWithEPK_ECC", _os, _context);
            }
        }

        virtual tars::Int32 generateKeyWithEPK_RSA(const Mitsurugi::PhSessionHandle & sessionHandle,tars::UInt32 uiKeyBits,const Mitsurugi::Tars_RSArefPublicKey & pucPublicKey,vector<tars::UInt8> &pucKey,tars::UInt32 &puiKeyLength,Mitsurugi::PhKeyHandle &keyHandle,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 generateKeyWithEPK_RSA(Mitsurugi::PhSessionHandle && sessionHandle,tars::UInt32 uiKeyBits,Mitsurugi::Tars_RSArefPublicKey && pucPublicKey,vector<tars::UInt8> &pucKey,tars::UInt32 &puiKeyLength,Mitsurugi::PhKeyHandle &keyHandle,tars::TarsCurrentPtr _current_) 
        { return generateKeyWithEPK_RSA(sessionHandle, uiKeyBits, pucPublicKey, pucKey, puiKeyLength, keyHandle, _current_); }
        static void async_response_generateKeyWithEPK_RSA(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const vector<tars::UInt8> &pucKey, tars::UInt32 puiKeyLength, const Mitsurugi::PhKeyHandle &keyHandle)
        {
            size_t _rsp_len_ = 0;
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("pucKey", pucKey);
                _tarsAttr_.put("puiKeyLength", puiKeyLength);
                _tarsAttr_.put("keyHandle", keyHandle);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
                _rsp_len_ = sTupResponseBuffer.size();
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["pucKey"] = tars::JsonOutput::writeJson(pucKey);
                _p->value["puiKeyLength"] = tars::JsonOutput::writeJson(puiKeyLength);
                _p->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
                _rsp_len_ = sJsonResponseBuffer.size();
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(pucKey, 4);

                _os.write(puiKeyLength, 5);

                _os.write(keyHandle, 6);

                _rsp_len_ = _os.getLength();
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
            if (_current_->isTraced())
            {
                string _trace_param_;
                int _trace_param_flag_ = ServantProxyThreadData::needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _current_->getTraceKey(), _rsp_len_);
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["pucKey"] = tars::JsonOutput::writeJson(pucKey);
                    _p_->value["puiKeyLength"] = tars::JsonOutput::writeJson(puiKeyLength);
                    _p_->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_current_->getTraceKey(), TRACE_ANNOTATION_SS, "", ServerConfig::Application + "." + ServerConfig::ServerName, "generateKeyWithEPK_RSA", 0, _trace_param_, "");
            }

        }
        static void async_response_push_generateKeyWithEPK_RSA(tars::CurrentPtr _current_, tars::Int32 _ret, const vector<tars::UInt8> &pucKey, tars::UInt32 puiKeyLength, const Mitsurugi::PhKeyHandle &keyHandle, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(pucKey, 4);

                _os.write(puiKeyLength, 5);

                _os.write(keyHandle, 6);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"generateKeyWithEPK_RSA", _os, _context);
            }
        }

        virtual tars::Int32 generateKeyWithIPK_ECC(const Mitsurugi::PhSessionHandle & sessionHandle,tars::UInt32 uiIPKIndex,tars::UInt32 uiKeyBits,Mitsurugi::Tars_ECCCipher &pucKey,Mitsurugi::PhKeyHandle &keyHandle,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 generateKeyWithIPK_ECC(Mitsurugi::PhSessionHandle && sessionHandle,tars::UInt32 uiIPKIndex,tars::UInt32 uiKeyBits,Mitsurugi::Tars_ECCCipher &pucKey,Mitsurugi::PhKeyHandle &keyHandle,tars::TarsCurrentPtr _current_) 
        { return generateKeyWithIPK_ECC(sessionHandle, uiIPKIndex, uiKeyBits, pucKey, keyHandle, _current_); }
        static void async_response_generateKeyWithIPK_ECC(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const Mitsurugi::Tars_ECCCipher &pucKey, const Mitsurugi::PhKeyHandle &keyHandle)
        {
            size_t _rsp_len_ = 0;
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("pucKey", pucKey);
                _tarsAttr_.put("keyHandle", keyHandle);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
                _rsp_len_ = sTupResponseBuffer.size();
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["pucKey"] = tars::JsonOutput::writeJson(pucKey);
                _p->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
                _rsp_len_ = sJsonResponseBuffer.size();
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(pucKey, 4);

                _os.write(keyHandle, 5);

                _rsp_len_ = _os.getLength();
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
            if (_current_->isTraced())
            {
                string _trace_param_;
                int _trace_param_flag_ = ServantProxyThreadData::needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _current_->getTraceKey(), _rsp_len_);
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["pucKey"] = tars::JsonOutput::writeJson(pucKey);
                    _p_->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_current_->getTraceKey(), TRACE_ANNOTATION_SS, "", ServerConfig::Application + "." + ServerConfig::ServerName, "generateKeyWithIPK_ECC", 0, _trace_param_, "");
            }

        }
        static void async_response_push_generateKeyWithIPK_ECC(tars::CurrentPtr _current_, tars::Int32 _ret, const Mitsurugi::Tars_ECCCipher &pucKey, const Mitsurugi::PhKeyHandle &keyHandle, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(pucKey, 4);

                _os.write(keyHandle, 5);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"generateKeyWithIPK_ECC", _os, _context);
            }
        }

        virtual tars::Int32 generateKeyWithIPK_RSA(const Mitsurugi::PhSessionHandle & sessionHandle,tars::UInt32 uiPKIIndex,tars::UInt32 uiKeyBits,vector<tars::UInt8> &pucKey,tars::UInt32 &puiKeyLength,Mitsurugi::PhKeyHandle &keyHandle,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 generateKeyWithIPK_RSA(Mitsurugi::PhSessionHandle && sessionHandle,tars::UInt32 uiPKIIndex,tars::UInt32 uiKeyBits,vector<tars::UInt8> &pucKey,tars::UInt32 &puiKeyLength,Mitsurugi::PhKeyHandle &keyHandle,tars::TarsCurrentPtr _current_) 
        { return generateKeyWithIPK_RSA(sessionHandle, uiPKIIndex, uiKeyBits, pucKey, puiKeyLength, keyHandle, _current_); }
        static void async_response_generateKeyWithIPK_RSA(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const vector<tars::UInt8> &pucKey, tars::UInt32 puiKeyLength, const Mitsurugi::PhKeyHandle &keyHandle)
        {
            size_t _rsp_len_ = 0;
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("pucKey", pucKey);
                _tarsAttr_.put("puiKeyLength", puiKeyLength);
                _tarsAttr_.put("keyHandle", keyHandle);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
                _rsp_len_ = sTupResponseBuffer.size();
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["pucKey"] = tars::JsonOutput::writeJson(pucKey);
                _p->value["puiKeyLength"] = tars::JsonOutput::writeJson(puiKeyLength);
                _p->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
                _rsp_len_ = sJsonResponseBuffer.size();
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(pucKey, 4);

                _os.write(puiKeyLength, 5);

                _os.write(keyHandle, 6);

                _rsp_len_ = _os.getLength();
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
            if (_current_->isTraced())
            {
                string _trace_param_;
                int _trace_param_flag_ = ServantProxyThreadData::needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _current_->getTraceKey(), _rsp_len_);
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["pucKey"] = tars::JsonOutput::writeJson(pucKey);
                    _p_->value["puiKeyLength"] = tars::JsonOutput::writeJson(puiKeyLength);
                    _p_->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_current_->getTraceKey(), TRACE_ANNOTATION_SS, "", ServerConfig::Application + "." + ServerConfig::ServerName, "generateKeyWithIPK_RSA", 0, _trace_param_, "");
            }

        }
        static void async_response_push_generateKeyWithIPK_RSA(tars::CurrentPtr _current_, tars::Int32 _ret, const vector<tars::UInt8> &pucKey, tars::UInt32 puiKeyLength, const Mitsurugi::PhKeyHandle &keyHandle, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(pucKey, 4);

                _os.write(puiKeyLength, 5);

                _os.write(keyHandle, 6);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"generateKeyWithIPK_RSA", _os, _context);
            }
        }

        virtual tars::Int32 generateKeyWithKEK(const Mitsurugi::PhSessionHandle & sessionHandle,tars::UInt32 uiKeyBits,tars::UInt32 uiAlgID,tars::UInt32 uiKEKIndex,vector<tars::UInt8> &pucKey,tars::UInt32 &puiKeyLength,Mitsurugi::PhKeyHandle &keyHandle,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 generateKeyWithKEK(Mitsurugi::PhSessionHandle && sessionHandle,tars::UInt32 uiKeyBits,tars::UInt32 uiAlgID,tars::UInt32 uiKEKIndex,vector<tars::UInt8> &pucKey,tars::UInt32 &puiKeyLength,Mitsurugi::PhKeyHandle &keyHandle,tars::TarsCurrentPtr _current_) 
        { return generateKeyWithKEK(sessionHandle, uiKeyBits, uiAlgID, uiKEKIndex, pucKey, puiKeyLength, keyHandle, _current_); }
        static void async_response_generateKeyWithKEK(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const vector<tars::UInt8> &pucKey, tars::UInt32 puiKeyLength, const Mitsurugi::PhKeyHandle &keyHandle)
        {
            size_t _rsp_len_ = 0;
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("pucKey", pucKey);
                _tarsAttr_.put("puiKeyLength", puiKeyLength);
                _tarsAttr_.put("keyHandle", keyHandle);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
                _rsp_len_ = sTupResponseBuffer.size();
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["pucKey"] = tars::JsonOutput::writeJson(pucKey);
                _p->value["puiKeyLength"] = tars::JsonOutput::writeJson(puiKeyLength);
                _p->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
                _rsp_len_ = sJsonResponseBuffer.size();
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(pucKey, 5);

                _os.write(puiKeyLength, 6);

                _os.write(keyHandle, 7);

                _rsp_len_ = _os.getLength();
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
            if (_current_->isTraced())
            {
                string _trace_param_;
                int _trace_param_flag_ = ServantProxyThreadData::needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _current_->getTraceKey(), _rsp_len_);
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["pucKey"] = tars::JsonOutput::writeJson(pucKey);
                    _p_->value["puiKeyLength"] = tars::JsonOutput::writeJson(puiKeyLength);
                    _p_->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_current_->getTraceKey(), TRACE_ANNOTATION_SS, "", ServerConfig::Application + "." + ServerConfig::ServerName, "generateKeyWithKEK", 0, _trace_param_, "");
            }

        }
        static void async_response_push_generateKeyWithKEK(tars::CurrentPtr _current_, tars::Int32 _ret, const vector<tars::UInt8> &pucKey, tars::UInt32 puiKeyLength, const Mitsurugi::PhKeyHandle &keyHandle, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(pucKey, 5);

                _os.write(puiKeyLength, 6);

                _os.write(keyHandle, 7);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"generateKeyWithKEK", _os, _context);
            }
        }

        virtual tars::Int32 importKey(const Mitsurugi::PhSessionHandle & sessionHandle,const vector<tars::UInt8> & pucKey,tars::UInt32 uiKeyLength,Mitsurugi::PhKeyHandle &keyHandle,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 importKey(Mitsurugi::PhSessionHandle && sessionHandle,vector<tars::UInt8> && pucKey,tars::UInt32 uiKeyLength,Mitsurugi::PhKeyHandle &keyHandle,tars::TarsCurrentPtr _current_) 
        { return importKey(sessionHandle, pucKey, uiKeyLength, keyHandle, _current_); }
        static void async_response_importKey(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const Mitsurugi::PhKeyHandle &keyHandle)
        {
            size_t _rsp_len_ = 0;
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("keyHandle", keyHandle);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
                _rsp_len_ = sTupResponseBuffer.size();
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
                _rsp_len_ = sJsonResponseBuffer.size();
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(keyHandle, 4);

                _rsp_len_ = _os.getLength();
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
            if (_current_->isTraced())
            {
                string _trace_param_;
                int _trace_param_flag_ = ServantProxyThreadData::needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _current_->getTraceKey(), _rsp_len_);
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_current_->getTraceKey(), TRACE_ANNOTATION_SS, "", ServerConfig::Application + "." + ServerConfig::ServerName, "importKey", 0, _trace_param_, "");
            }

        }
        static void async_response_push_importKey(tars::CurrentPtr _current_, tars::Int32 _ret, const Mitsurugi::PhKeyHandle &keyHandle, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(keyHandle, 4);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"importKey", _os, _context);
            }
        }

        virtual tars::Int32 importKeyWithISK_ECC(const Mitsurugi::PhSessionHandle & sessionHandle,tars::UInt32 uiISKIndex,const Mitsurugi::Tars_ECCCipher & pucKey,Mitsurugi::PhKeyHandle &keyHandle,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 importKeyWithISK_ECC(Mitsurugi::PhSessionHandle && sessionHandle,tars::UInt32 uiISKIndex,Mitsurugi::Tars_ECCCipher && pucKey,Mitsurugi::PhKeyHandle &keyHandle,tars::TarsCurrentPtr _current_) 
        { return importKeyWithISK_ECC(sessionHandle, uiISKIndex, pucKey, keyHandle, _current_); }
        static void async_response_importKeyWithISK_ECC(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const Mitsurugi::PhKeyHandle &keyHandle)
        {
            size_t _rsp_len_ = 0;
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("keyHandle", keyHandle);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
                _rsp_len_ = sTupResponseBuffer.size();
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
                _rsp_len_ = sJsonResponseBuffer.size();
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(keyHandle, 4);

                _rsp_len_ = _os.getLength();
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
            if (_current_->isTraced())
            {
                string _trace_param_;
                int _trace_param_flag_ = ServantProxyThreadData::needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _current_->getTraceKey(), _rsp_len_);
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_current_->getTraceKey(), TRACE_ANNOTATION_SS, "", ServerConfig::Application + "." + ServerConfig::ServerName, "importKeyWithISK_ECC", 0, _trace_param_, "");
            }

        }
        static void async_response_push_importKeyWithISK_ECC(tars::CurrentPtr _current_, tars::Int32 _ret, const Mitsurugi::PhKeyHandle &keyHandle, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(keyHandle, 4);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"importKeyWithISK_ECC", _os, _context);
            }
        }

        virtual tars::Int32 importKeyWithISK_RSA(const Mitsurugi::PhSessionHandle & sessionHandle,tars::UInt32 uiISKIndex,const vector<tars::UInt8> & pucKey,tars::UInt32 puiKeyLength,Mitsurugi::PhKeyHandle &keyHandle,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 importKeyWithISK_RSA(Mitsurugi::PhSessionHandle && sessionHandle,tars::UInt32 uiISKIndex,vector<tars::UInt8> && pucKey,tars::UInt32 puiKeyLength,Mitsurugi::PhKeyHandle &keyHandle,tars::TarsCurrentPtr _current_) 
        { return importKeyWithISK_RSA(sessionHandle, uiISKIndex, pucKey, puiKeyLength, keyHandle, _current_); }
        static void async_response_importKeyWithISK_RSA(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const Mitsurugi::PhKeyHandle &keyHandle)
        {
            size_t _rsp_len_ = 0;
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("keyHandle", keyHandle);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
                _rsp_len_ = sTupResponseBuffer.size();
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
                _rsp_len_ = sJsonResponseBuffer.size();
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(keyHandle, 5);

                _rsp_len_ = _os.getLength();
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
            if (_current_->isTraced())
            {
                string _trace_param_;
                int _trace_param_flag_ = ServantProxyThreadData::needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _current_->getTraceKey(), _rsp_len_);
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_current_->getTraceKey(), TRACE_ANNOTATION_SS, "", ServerConfig::Application + "." + ServerConfig::ServerName, "importKeyWithISK_RSA", 0, _trace_param_, "");
            }

        }
        static void async_response_push_importKeyWithISK_RSA(tars::CurrentPtr _current_, tars::Int32 _ret, const Mitsurugi::PhKeyHandle &keyHandle, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(keyHandle, 5);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"importKeyWithISK_RSA", _os, _context);
            }
        }

        virtual tars::Int32 importKeyWithKEK(const Mitsurugi::PhSessionHandle & sessionHandle,tars::UInt32 uiAlgID,tars::UInt32 uiKEKIndex,const vector<tars::UInt8> & pucKey,tars::UInt32 puiKeyLength,Mitsurugi::PhKeyHandle &keyHandle,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Int32 importKeyWithKEK(Mitsurugi::PhSessionHandle && sessionHandle,tars::UInt32 uiAlgID,tars::UInt32 uiKEKIndex,vector<tars::UInt8> && pucKey,tars::UInt32 puiKeyLength,Mitsurugi::PhKeyHandle &keyHandle,tars::TarsCurrentPtr _current_) 
        { return importKeyWithKEK(sessionHandle, uiAlgID, uiKEKIndex, pucKey, puiKeyLength, keyHandle, _current_); }
        static void async_response_importKeyWithKEK(tars::TarsCurrentPtr _current_, tars::Int32 _ret, const Mitsurugi::PhKeyHandle &keyHandle)
        {
            size_t _rsp_len_ = 0;
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("keyHandle", keyHandle);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
                _rsp_len_ = sTupResponseBuffer.size();
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
                _rsp_len_ = sJsonResponseBuffer.size();
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(keyHandle, 6);

                _rsp_len_ = _os.getLength();
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
            if (_current_->isTraced())
            {
                string _trace_param_;
                int _trace_param_flag_ = ServantProxyThreadData::needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _current_->getTraceKey(), _rsp_len_);
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_current_->getTraceKey(), TRACE_ANNOTATION_SS, "", ServerConfig::Application + "." + ServerConfig::ServerName, "importKeyWithKEK", 0, _trace_param_, "");
            }

        }
        static void async_response_push_importKeyWithKEK(tars::CurrentPtr _current_, tars::Int32 _ret, const Mitsurugi::PhKeyHandle &keyHandle, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(keyHandle, 6);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"importKeyWithKEK", _os, _context);
            }
        }

    public:
        int onDispatch(tars::TarsCurrentPtr _current, vector<char> &_sResponseBuffer)
        {
            static ::std::string __Mitsurugi__KeyManage_all[]=
            {
                "destroyKey",
                "exchangeDigitEncelopeBaseOnECC",
                "exchangeDigitEnvelopeBaseOnRSA",
                "exportEncPublicKey_ECC",
                "exportEncPublicKey_RSA",
                "exportSignPublicKey_ECC",
                "exportSignPublicKey_RSA",
                "generateAgreementDataAndKeyWithECC",
                "generateAgreementDataWithECC",
                "generateKeyPair_ECC",
                "generateKeyPair_RSA",
                "generateKeyWithECC",
                "generateKeyWithEPK_ECC",
                "generateKeyWithEPK_RSA",
                "generateKeyWithIPK_ECC",
                "generateKeyWithIPK_RSA",
                "generateKeyWithKEK",
                "importKey",
                "importKeyWithISK_ECC",
                "importKeyWithISK_RSA",
                "importKeyWithKEK"
            };

            pair<string*, string*> r = equal_range(__Mitsurugi__KeyManage_all, __Mitsurugi__KeyManage_all+21, _current->getFuncName());
            if(r.first == r.second) return tars::TARSSERVERNOFUNCERR;
            switch(r.first - __Mitsurugi__KeyManage_all)
            {
                case 0:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    Mitsurugi::PhSessionHandle sessionHandle;
                    Mitsurugi::PhKeyHandle keyHandle;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("sessionHandle", sessionHandle);
                        _tarsAttr_.get("keyHandle", keyHandle);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(sessionHandle, _jsonPtr->value["sessionHandle"], true);
                        tars::JsonInput::readJson(keyHandle, _jsonPtr->value["keyHandle"], true);
                    }
                    else
                    {
                        _is.read(sessionHandle, 1, true);
                        _is.read(keyHandle, 2, true);
                    }
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                            _p_->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SR), TRACE_ANNOTATION_SR, "", ServerConfig::Application + "." + ServerConfig::ServerName, "destroyKey", 0, _trace_param_, "");
                    }

                    tars::Int32 _ret = destroyKey(std::move(sessionHandle),std::move(keyHandle), _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.swap(_sResponseBuffer);
                        }
                        if (_pSptd_ && _pSptd_->_traceCall)
                        {
                            string _trace_param_;
                            int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _sResponseBuffer.size());
                            if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                            {
                                tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                                _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                                _trace_param_ = tars::TC_Json::writeValue(_p_);
                            }
                            else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                            {
                                _trace_param_ = "{\"trace_param_over_max_len\":true}";
                            }
                            TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS), TRACE_ANNOTATION_SS, "", ServerConfig::Application + "." + ServerConfig::ServerName, "destroyKey", 0, _trace_param_, "");
                        }

                    }
                    else if(_pSptd_ && _pSptd_->_traceCall)
                    {
                        _current->setTrace(_pSptd_->_traceCall, _pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS));
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    Mitsurugi::PhSessionHandle sessionHandle;
                    tars::UInt32 uiKeyIndex;
                    tars::UInt32 uiAlgID;
                    Mitsurugi::Tars_ECCrefPublicKey pucPublicKey;
                    Mitsurugi::Tars_ECCCipher pucEncDataIn;
                    Mitsurugi::Tars_ECCCipher pucEncDataOut;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("sessionHandle", sessionHandle);
                        _tarsAttr_.get("uiKeyIndex", uiKeyIndex);
                        _tarsAttr_.get("uiAlgID", uiAlgID);
                        _tarsAttr_.get("pucPublicKey", pucPublicKey);
                        _tarsAttr_.get("pucEncDataIn", pucEncDataIn);
                        _tarsAttr_.getByDefault("pucEncDataOut", pucEncDataOut, pucEncDataOut);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(sessionHandle, _jsonPtr->value["sessionHandle"], true);
                        tars::JsonInput::readJson(uiKeyIndex, _jsonPtr->value["uiKeyIndex"], true);
                        tars::JsonInput::readJson(uiAlgID, _jsonPtr->value["uiAlgID"], true);
                        tars::JsonInput::readJson(pucPublicKey, _jsonPtr->value["pucPublicKey"], true);
                        tars::JsonInput::readJson(pucEncDataIn, _jsonPtr->value["pucEncDataIn"], true);
                        tars::JsonInput::readJson(pucEncDataOut, _jsonPtr->value["pucEncDataOut"], false);
                    }
                    else
                    {
                        _is.read(sessionHandle, 1, true);
                        _is.read(uiKeyIndex, 2, true);
                        _is.read(uiAlgID, 3, true);
                        _is.read(pucPublicKey, 4, true);
                        _is.read(pucEncDataIn, 5, true);
                        _is.read(pucEncDataOut, 6, false);
                    }
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                            _p_->value["uiKeyIndex"] = tars::JsonOutput::writeJson(uiKeyIndex);
                            _p_->value["uiAlgID"] = tars::JsonOutput::writeJson(uiAlgID);
                            _p_->value["pucPublicKey"] = tars::JsonOutput::writeJson(pucPublicKey);
                            _p_->value["pucEncDataIn"] = tars::JsonOutput::writeJson(pucEncDataIn);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SR), TRACE_ANNOTATION_SR, "", ServerConfig::Application + "." + ServerConfig::ServerName, "exchangeDigitEncelopeBaseOnECC", 0, _trace_param_, "");
                    }

                    tars::Int32 _ret = exchangeDigitEncelopeBaseOnECC(std::move(sessionHandle),uiKeyIndex,uiAlgID,std::move(pucPublicKey),std::move(pucEncDataIn),pucEncDataOut, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("pucEncDataOut", pucEncDataOut);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["pucEncDataOut"] = tars::JsonOutput::writeJson(pucEncDataOut);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(pucEncDataOut, 6);
                            _os.swap(_sResponseBuffer);
                        }
                        if (_pSptd_ && _pSptd_->_traceCall)
                        {
                            string _trace_param_;
                            int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _sResponseBuffer.size());
                            if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                            {
                                tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                                _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                                _p_->value["pucEncDataOut"] = tars::JsonOutput::writeJson(pucEncDataOut);
                                _trace_param_ = tars::TC_Json::writeValue(_p_);
                            }
                            else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                            {
                                _trace_param_ = "{\"trace_param_over_max_len\":true}";
                            }
                            TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS), TRACE_ANNOTATION_SS, "", ServerConfig::Application + "." + ServerConfig::ServerName, "exchangeDigitEncelopeBaseOnECC", 0, _trace_param_, "");
                        }

                    }
                    else if(_pSptd_ && _pSptd_->_traceCall)
                    {
                        _current->setTrace(_pSptd_->_traceCall, _pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS));
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    Mitsurugi::PhSessionHandle sessionHandle;
                    tars::UInt32 uiKeyIndex;
                    Mitsurugi::Tars_RSArefPublicKey pucPublicKey;
                    vector<tars::UInt8> pucDEInput;
                    tars::UInt32 uiDELength;
                    vector<tars::UInt8> pucDEOutput;
                    tars::UInt32 puiDELength;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("sessionHandle", sessionHandle);
                        _tarsAttr_.get("uiKeyIndex", uiKeyIndex);
                        _tarsAttr_.get("pucPublicKey", pucPublicKey);
                        _tarsAttr_.get("pucDEInput", pucDEInput);
                        _tarsAttr_.get("uiDELength", uiDELength);
                        _tarsAttr_.getByDefault("pucDEOutput", pucDEOutput, pucDEOutput);
                        _tarsAttr_.getByDefault("puiDELength", puiDELength, puiDELength);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(sessionHandle, _jsonPtr->value["sessionHandle"], true);
                        tars::JsonInput::readJson(uiKeyIndex, _jsonPtr->value["uiKeyIndex"], true);
                        tars::JsonInput::readJson(pucPublicKey, _jsonPtr->value["pucPublicKey"], true);
                        tars::JsonInput::readJson(pucDEInput, _jsonPtr->value["pucDEInput"], true);
                        tars::JsonInput::readJson(uiDELength, _jsonPtr->value["uiDELength"], true);
                        tars::JsonInput::readJson(pucDEOutput, _jsonPtr->value["pucDEOutput"], false);
                        tars::JsonInput::readJson(puiDELength, _jsonPtr->value["puiDELength"], false);
                    }
                    else
                    {
                        _is.read(sessionHandle, 1, true);
                        _is.read(uiKeyIndex, 2, true);
                        _is.read(pucPublicKey, 3, true);
                        _is.read(pucDEInput, 4, true);
                        _is.read(uiDELength, 5, true);
                        _is.read(pucDEOutput, 6, false);
                        _is.read(puiDELength, 7, false);
                    }
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                            _p_->value["uiKeyIndex"] = tars::JsonOutput::writeJson(uiKeyIndex);
                            _p_->value["pucPublicKey"] = tars::JsonOutput::writeJson(pucPublicKey);
                            _p_->value["pucDEInput"] = tars::JsonOutput::writeJson(pucDEInput);
                            _p_->value["uiDELength"] = tars::JsonOutput::writeJson(uiDELength);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SR), TRACE_ANNOTATION_SR, "", ServerConfig::Application + "." + ServerConfig::ServerName, "exchangeDigitEnvelopeBaseOnRSA", 0, _trace_param_, "");
                    }

                    tars::Int32 _ret = exchangeDigitEnvelopeBaseOnRSA(std::move(sessionHandle),uiKeyIndex,std::move(pucPublicKey),std::move(pucDEInput),uiDELength,pucDEOutput,puiDELength, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("pucDEOutput", pucDEOutput);
                            _tarsAttr_.put("puiDELength", puiDELength);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["pucDEOutput"] = tars::JsonOutput::writeJson(pucDEOutput);
                            _p->value["puiDELength"] = tars::JsonOutput::writeJson(puiDELength);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(pucDEOutput, 6);
                            _os.write(puiDELength, 7);
                            _os.swap(_sResponseBuffer);
                        }
                        if (_pSptd_ && _pSptd_->_traceCall)
                        {
                            string _trace_param_;
                            int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _sResponseBuffer.size());
                            if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                            {
                                tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                                _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                                _p_->value["pucDEOutput"] = tars::JsonOutput::writeJson(pucDEOutput);
                                _p_->value["puiDELength"] = tars::JsonOutput::writeJson(puiDELength);
                                _trace_param_ = tars::TC_Json::writeValue(_p_);
                            }
                            else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                            {
                                _trace_param_ = "{\"trace_param_over_max_len\":true}";
                            }
                            TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS), TRACE_ANNOTATION_SS, "", ServerConfig::Application + "." + ServerConfig::ServerName, "exchangeDigitEnvelopeBaseOnRSA", 0, _trace_param_, "");
                        }

                    }
                    else if(_pSptd_ && _pSptd_->_traceCall)
                    {
                        _current->setTrace(_pSptd_->_traceCall, _pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS));
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    Mitsurugi::PhSessionHandle sessionHandle;
                    tars::UInt32 uiKeyIndex;
                    Mitsurugi::Tars_ECCrefPublicKey pucPublicKey;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("sessionHandle", sessionHandle);
                        _tarsAttr_.get("uiKeyIndex", uiKeyIndex);
                        _tarsAttr_.getByDefault("pucPublicKey", pucPublicKey, pucPublicKey);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(sessionHandle, _jsonPtr->value["sessionHandle"], true);
                        tars::JsonInput::readJson(uiKeyIndex, _jsonPtr->value["uiKeyIndex"], true);
                        tars::JsonInput::readJson(pucPublicKey, _jsonPtr->value["pucPublicKey"], false);
                    }
                    else
                    {
                        _is.read(sessionHandle, 1, true);
                        _is.read(uiKeyIndex, 2, true);
                        _is.read(pucPublicKey, 3, false);
                    }
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                            _p_->value["uiKeyIndex"] = tars::JsonOutput::writeJson(uiKeyIndex);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SR), TRACE_ANNOTATION_SR, "", ServerConfig::Application + "." + ServerConfig::ServerName, "exportEncPublicKey_ECC", 0, _trace_param_, "");
                    }

                    tars::Int32 _ret = exportEncPublicKey_ECC(std::move(sessionHandle),uiKeyIndex,pucPublicKey, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("pucPublicKey", pucPublicKey);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["pucPublicKey"] = tars::JsonOutput::writeJson(pucPublicKey);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(pucPublicKey, 3);
                            _os.swap(_sResponseBuffer);
                        }
                        if (_pSptd_ && _pSptd_->_traceCall)
                        {
                            string _trace_param_;
                            int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _sResponseBuffer.size());
                            if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                            {
                                tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                                _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                                _p_->value["pucPublicKey"] = tars::JsonOutput::writeJson(pucPublicKey);
                                _trace_param_ = tars::TC_Json::writeValue(_p_);
                            }
                            else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                            {
                                _trace_param_ = "{\"trace_param_over_max_len\":true}";
                            }
                            TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS), TRACE_ANNOTATION_SS, "", ServerConfig::Application + "." + ServerConfig::ServerName, "exportEncPublicKey_ECC", 0, _trace_param_, "");
                        }

                    }
                    else if(_pSptd_ && _pSptd_->_traceCall)
                    {
                        _current->setTrace(_pSptd_->_traceCall, _pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS));
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 4:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    Mitsurugi::PhSessionHandle sessionHandle;
                    tars::UInt32 uiKeyIndex;
                    Mitsurugi::Tars_RSArefPublicKey pucPublicKey;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("sessionHandle", sessionHandle);
                        _tarsAttr_.get("uiKeyIndex", uiKeyIndex);
                        _tarsAttr_.getByDefault("pucPublicKey", pucPublicKey, pucPublicKey);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(sessionHandle, _jsonPtr->value["sessionHandle"], true);
                        tars::JsonInput::readJson(uiKeyIndex, _jsonPtr->value["uiKeyIndex"], true);
                        tars::JsonInput::readJson(pucPublicKey, _jsonPtr->value["pucPublicKey"], false);
                    }
                    else
                    {
                        _is.read(sessionHandle, 1, true);
                        _is.read(uiKeyIndex, 2, true);
                        _is.read(pucPublicKey, 3, false);
                    }
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                            _p_->value["uiKeyIndex"] = tars::JsonOutput::writeJson(uiKeyIndex);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SR), TRACE_ANNOTATION_SR, "", ServerConfig::Application + "." + ServerConfig::ServerName, "exportEncPublicKey_RSA", 0, _trace_param_, "");
                    }

                    tars::Int32 _ret = exportEncPublicKey_RSA(std::move(sessionHandle),uiKeyIndex,pucPublicKey, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("pucPublicKey", pucPublicKey);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["pucPublicKey"] = tars::JsonOutput::writeJson(pucPublicKey);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(pucPublicKey, 3);
                            _os.swap(_sResponseBuffer);
                        }
                        if (_pSptd_ && _pSptd_->_traceCall)
                        {
                            string _trace_param_;
                            int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _sResponseBuffer.size());
                            if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                            {
                                tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                                _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                                _p_->value["pucPublicKey"] = tars::JsonOutput::writeJson(pucPublicKey);
                                _trace_param_ = tars::TC_Json::writeValue(_p_);
                            }
                            else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                            {
                                _trace_param_ = "{\"trace_param_over_max_len\":true}";
                            }
                            TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS), TRACE_ANNOTATION_SS, "", ServerConfig::Application + "." + ServerConfig::ServerName, "exportEncPublicKey_RSA", 0, _trace_param_, "");
                        }

                    }
                    else if(_pSptd_ && _pSptd_->_traceCall)
                    {
                        _current->setTrace(_pSptd_->_traceCall, _pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS));
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 5:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    Mitsurugi::PhSessionHandle sessionHandle;
                    tars::UInt32 uiKeyIndex;
                    Mitsurugi::Tars_ECCrefPublicKey pucPublicKey;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("sessionHandle", sessionHandle);
                        _tarsAttr_.get("uiKeyIndex", uiKeyIndex);
                        _tarsAttr_.getByDefault("pucPublicKey", pucPublicKey, pucPublicKey);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(sessionHandle, _jsonPtr->value["sessionHandle"], true);
                        tars::JsonInput::readJson(uiKeyIndex, _jsonPtr->value["uiKeyIndex"], true);
                        tars::JsonInput::readJson(pucPublicKey, _jsonPtr->value["pucPublicKey"], false);
                    }
                    else
                    {
                        _is.read(sessionHandle, 1, true);
                        _is.read(uiKeyIndex, 2, true);
                        _is.read(pucPublicKey, 3, false);
                    }
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                            _p_->value["uiKeyIndex"] = tars::JsonOutput::writeJson(uiKeyIndex);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SR), TRACE_ANNOTATION_SR, "", ServerConfig::Application + "." + ServerConfig::ServerName, "exportSignPublicKey_ECC", 0, _trace_param_, "");
                    }

                    tars::Int32 _ret = exportSignPublicKey_ECC(std::move(sessionHandle),uiKeyIndex,pucPublicKey, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("pucPublicKey", pucPublicKey);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["pucPublicKey"] = tars::JsonOutput::writeJson(pucPublicKey);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(pucPublicKey, 3);
                            _os.swap(_sResponseBuffer);
                        }
                        if (_pSptd_ && _pSptd_->_traceCall)
                        {
                            string _trace_param_;
                            int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _sResponseBuffer.size());
                            if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                            {
                                tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                                _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                                _p_->value["pucPublicKey"] = tars::JsonOutput::writeJson(pucPublicKey);
                                _trace_param_ = tars::TC_Json::writeValue(_p_);
                            }
                            else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                            {
                                _trace_param_ = "{\"trace_param_over_max_len\":true}";
                            }
                            TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS), TRACE_ANNOTATION_SS, "", ServerConfig::Application + "." + ServerConfig::ServerName, "exportSignPublicKey_ECC", 0, _trace_param_, "");
                        }

                    }
                    else if(_pSptd_ && _pSptd_->_traceCall)
                    {
                        _current->setTrace(_pSptd_->_traceCall, _pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS));
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 6:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    Mitsurugi::PhSessionHandle sessionHandle;
                    tars::UInt32 uiKeyIndex;
                    Mitsurugi::Tars_RSArefPublicKey pucPublicKey;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("sessionHandle", sessionHandle);
                        _tarsAttr_.get("uiKeyIndex", uiKeyIndex);
                        _tarsAttr_.getByDefault("pucPublicKey", pucPublicKey, pucPublicKey);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(sessionHandle, _jsonPtr->value["sessionHandle"], true);
                        tars::JsonInput::readJson(uiKeyIndex, _jsonPtr->value["uiKeyIndex"], true);
                        tars::JsonInput::readJson(pucPublicKey, _jsonPtr->value["pucPublicKey"], false);
                    }
                    else
                    {
                        _is.read(sessionHandle, 1, true);
                        _is.read(uiKeyIndex, 2, true);
                        _is.read(pucPublicKey, 3, false);
                    }
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                            _p_->value["uiKeyIndex"] = tars::JsonOutput::writeJson(uiKeyIndex);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SR), TRACE_ANNOTATION_SR, "", ServerConfig::Application + "." + ServerConfig::ServerName, "exportSignPublicKey_RSA", 0, _trace_param_, "");
                    }

                    tars::Int32 _ret = exportSignPublicKey_RSA(std::move(sessionHandle),uiKeyIndex,pucPublicKey, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("pucPublicKey", pucPublicKey);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["pucPublicKey"] = tars::JsonOutput::writeJson(pucPublicKey);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(pucPublicKey, 3);
                            _os.swap(_sResponseBuffer);
                        }
                        if (_pSptd_ && _pSptd_->_traceCall)
                        {
                            string _trace_param_;
                            int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _sResponseBuffer.size());
                            if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                            {
                                tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                                _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                                _p_->value["pucPublicKey"] = tars::JsonOutput::writeJson(pucPublicKey);
                                _trace_param_ = tars::TC_Json::writeValue(_p_);
                            }
                            else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                            {
                                _trace_param_ = "{\"trace_param_over_max_len\":true}";
                            }
                            TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS), TRACE_ANNOTATION_SS, "", ServerConfig::Application + "." + ServerConfig::ServerName, "exportSignPublicKey_RSA", 0, _trace_param_, "");
                        }

                    }
                    else if(_pSptd_ && _pSptd_->_traceCall)
                    {
                        _current->setTrace(_pSptd_->_traceCall, _pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS));
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 7:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    Mitsurugi::PhSessionHandle sessionHandle;
                    tars::UInt32 uiISKIndex;
                    tars::UInt32 uiKeyBits;
                    vector<tars::UInt8> pucResponseID;
                    tars::UInt32 uiResponseIDLength;
                    vector<tars::UInt8> pucSponsorID;
                    tars::UInt32 uiSponsorIDLength;
                    Mitsurugi::Tars_ECCrefPublicKey pucSponsorPublicKey;
                    Mitsurugi::Tars_ECCrefPublicKey pucSponsorTmpPublicKey;
                    Mitsurugi::Tars_ECCrefPublicKey pucResponsePublicKey;
                    Mitsurugi::Tars_ECCrefPublicKey pucResponseTmpPublicKey;
                    Mitsurugi::PhKeyHandle keyHandle;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("sessionHandle", sessionHandle);
                        _tarsAttr_.get("uiISKIndex", uiISKIndex);
                        _tarsAttr_.get("uiKeyBits", uiKeyBits);
                        _tarsAttr_.get("pucResponseID", pucResponseID);
                        _tarsAttr_.get("uiResponseIDLength", uiResponseIDLength);
                        _tarsAttr_.get("pucSponsorID", pucSponsorID);
                        _tarsAttr_.get("uiSponsorIDLength", uiSponsorIDLength);
                        _tarsAttr_.get("pucSponsorPublicKey", pucSponsorPublicKey);
                        _tarsAttr_.get("pucSponsorTmpPublicKey", pucSponsorTmpPublicKey);
                        _tarsAttr_.getByDefault("pucResponsePublicKey", pucResponsePublicKey, pucResponsePublicKey);
                        _tarsAttr_.getByDefault("pucResponseTmpPublicKey", pucResponseTmpPublicKey, pucResponseTmpPublicKey);
                        _tarsAttr_.getByDefault("keyHandle", keyHandle, keyHandle);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(sessionHandle, _jsonPtr->value["sessionHandle"], true);
                        tars::JsonInput::readJson(uiISKIndex, _jsonPtr->value["uiISKIndex"], true);
                        tars::JsonInput::readJson(uiKeyBits, _jsonPtr->value["uiKeyBits"], true);
                        tars::JsonInput::readJson(pucResponseID, _jsonPtr->value["pucResponseID"], true);
                        tars::JsonInput::readJson(uiResponseIDLength, _jsonPtr->value["uiResponseIDLength"], true);
                        tars::JsonInput::readJson(pucSponsorID, _jsonPtr->value["pucSponsorID"], true);
                        tars::JsonInput::readJson(uiSponsorIDLength, _jsonPtr->value["uiSponsorIDLength"], true);
                        tars::JsonInput::readJson(pucSponsorPublicKey, _jsonPtr->value["pucSponsorPublicKey"], true);
                        tars::JsonInput::readJson(pucSponsorTmpPublicKey, _jsonPtr->value["pucSponsorTmpPublicKey"], true);
                        tars::JsonInput::readJson(pucResponsePublicKey, _jsonPtr->value["pucResponsePublicKey"], false);
                        tars::JsonInput::readJson(pucResponseTmpPublicKey, _jsonPtr->value["pucResponseTmpPublicKey"], false);
                        tars::JsonInput::readJson(keyHandle, _jsonPtr->value["keyHandle"], false);
                    }
                    else
                    {
                        _is.read(sessionHandle, 1, true);
                        _is.read(uiISKIndex, 2, true);
                        _is.read(uiKeyBits, 3, true);
                        _is.read(pucResponseID, 4, true);
                        _is.read(uiResponseIDLength, 5, true);
                        _is.read(pucSponsorID, 6, true);
                        _is.read(uiSponsorIDLength, 7, true);
                        _is.read(pucSponsorPublicKey, 8, true);
                        _is.read(pucSponsorTmpPublicKey, 9, true);
                        _is.read(pucResponsePublicKey, 10, false);
                        _is.read(pucResponseTmpPublicKey, 11, false);
                        _is.read(keyHandle, 12, false);
                    }
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                            _p_->value["uiISKIndex"] = tars::JsonOutput::writeJson(uiISKIndex);
                            _p_->value["uiKeyBits"] = tars::JsonOutput::writeJson(uiKeyBits);
                            _p_->value["pucResponseID"] = tars::JsonOutput::writeJson(pucResponseID);
                            _p_->value["uiResponseIDLength"] = tars::JsonOutput::writeJson(uiResponseIDLength);
                            _p_->value["pucSponsorID"] = tars::JsonOutput::writeJson(pucSponsorID);
                            _p_->value["uiSponsorIDLength"] = tars::JsonOutput::writeJson(uiSponsorIDLength);
                            _p_->value["pucSponsorPublicKey"] = tars::JsonOutput::writeJson(pucSponsorPublicKey);
                            _p_->value["pucSponsorTmpPublicKey"] = tars::JsonOutput::writeJson(pucSponsorTmpPublicKey);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SR), TRACE_ANNOTATION_SR, "", ServerConfig::Application + "." + ServerConfig::ServerName, "generateAgreementDataAndKeyWithECC", 0, _trace_param_, "");
                    }

                    tars::Int32 _ret = generateAgreementDataAndKeyWithECC(std::move(sessionHandle),uiISKIndex,uiKeyBits,std::move(pucResponseID),uiResponseIDLength,std::move(pucSponsorID),uiSponsorIDLength,std::move(pucSponsorPublicKey),std::move(pucSponsorTmpPublicKey),pucResponsePublicKey,pucResponseTmpPublicKey,keyHandle, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("pucResponsePublicKey", pucResponsePublicKey);
                            _tarsAttr_.put("pucResponseTmpPublicKey", pucResponseTmpPublicKey);
                            _tarsAttr_.put("keyHandle", keyHandle);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["pucResponsePublicKey"] = tars::JsonOutput::writeJson(pucResponsePublicKey);
                            _p->value["pucResponseTmpPublicKey"] = tars::JsonOutput::writeJson(pucResponseTmpPublicKey);
                            _p->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(pucResponsePublicKey, 10);
                            _os.write(pucResponseTmpPublicKey, 11);
                            _os.write(keyHandle, 12);
                            _os.swap(_sResponseBuffer);
                        }
                        if (_pSptd_ && _pSptd_->_traceCall)
                        {
                            string _trace_param_;
                            int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _sResponseBuffer.size());
                            if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                            {
                                tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                                _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                                _p_->value["pucResponsePublicKey"] = tars::JsonOutput::writeJson(pucResponsePublicKey);
                                _p_->value["pucResponseTmpPublicKey"] = tars::JsonOutput::writeJson(pucResponseTmpPublicKey);
                                _p_->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                                _trace_param_ = tars::TC_Json::writeValue(_p_);
                            }
                            else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                            {
                                _trace_param_ = "{\"trace_param_over_max_len\":true}";
                            }
                            TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS), TRACE_ANNOTATION_SS, "", ServerConfig::Application + "." + ServerConfig::ServerName, "generateAgreementDataAndKeyWithECC", 0, _trace_param_, "");
                        }

                    }
                    else if(_pSptd_ && _pSptd_->_traceCall)
                    {
                        _current->setTrace(_pSptd_->_traceCall, _pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS));
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 8:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    Mitsurugi::PhSessionHandle sessionHandle;
                    tars::UInt32 uiISKIndex;
                    tars::UInt32 uiKeyBits;
                    vector<tars::UInt8> pucSponsorID;
                    tars::UInt32 uiSponsorIDLength;
                    Mitsurugi::Tars_ECCrefPublicKey pucSponsorPublicKey;
                    Mitsurugi::Tars_ECCrefPublicKey pucSponsorTmpPublicKey;
                    Mitsurugi::PhAgreementHandle agreementHandle;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("sessionHandle", sessionHandle);
                        _tarsAttr_.get("uiISKIndex", uiISKIndex);
                        _tarsAttr_.get("uiKeyBits", uiKeyBits);
                        _tarsAttr_.get("pucSponsorID", pucSponsorID);
                        _tarsAttr_.get("uiSponsorIDLength", uiSponsorIDLength);
                        _tarsAttr_.getByDefault("pucSponsorPublicKey", pucSponsorPublicKey, pucSponsorPublicKey);
                        _tarsAttr_.getByDefault("pucSponsorTmpPublicKey", pucSponsorTmpPublicKey, pucSponsorTmpPublicKey);
                        _tarsAttr_.getByDefault("agreementHandle", agreementHandle, agreementHandle);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(sessionHandle, _jsonPtr->value["sessionHandle"], true);
                        tars::JsonInput::readJson(uiISKIndex, _jsonPtr->value["uiISKIndex"], true);
                        tars::JsonInput::readJson(uiKeyBits, _jsonPtr->value["uiKeyBits"], true);
                        tars::JsonInput::readJson(pucSponsorID, _jsonPtr->value["pucSponsorID"], true);
                        tars::JsonInput::readJson(uiSponsorIDLength, _jsonPtr->value["uiSponsorIDLength"], true);
                        tars::JsonInput::readJson(pucSponsorPublicKey, _jsonPtr->value["pucSponsorPublicKey"], false);
                        tars::JsonInput::readJson(pucSponsorTmpPublicKey, _jsonPtr->value["pucSponsorTmpPublicKey"], false);
                        tars::JsonInput::readJson(agreementHandle, _jsonPtr->value["agreementHandle"], false);
                    }
                    else
                    {
                        _is.read(sessionHandle, 1, true);
                        _is.read(uiISKIndex, 2, true);
                        _is.read(uiKeyBits, 3, true);
                        _is.read(pucSponsorID, 4, true);
                        _is.read(uiSponsorIDLength, 5, true);
                        _is.read(pucSponsorPublicKey, 6, false);
                        _is.read(pucSponsorTmpPublicKey, 7, false);
                        _is.read(agreementHandle, 8, false);
                    }
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                            _p_->value["uiISKIndex"] = tars::JsonOutput::writeJson(uiISKIndex);
                            _p_->value["uiKeyBits"] = tars::JsonOutput::writeJson(uiKeyBits);
                            _p_->value["pucSponsorID"] = tars::JsonOutput::writeJson(pucSponsorID);
                            _p_->value["uiSponsorIDLength"] = tars::JsonOutput::writeJson(uiSponsorIDLength);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SR), TRACE_ANNOTATION_SR, "", ServerConfig::Application + "." + ServerConfig::ServerName, "generateAgreementDataWithECC", 0, _trace_param_, "");
                    }

                    tars::Int32 _ret = generateAgreementDataWithECC(std::move(sessionHandle),uiISKIndex,uiKeyBits,std::move(pucSponsorID),uiSponsorIDLength,pucSponsorPublicKey,pucSponsorTmpPublicKey,agreementHandle, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("pucSponsorPublicKey", pucSponsorPublicKey);
                            _tarsAttr_.put("pucSponsorTmpPublicKey", pucSponsorTmpPublicKey);
                            _tarsAttr_.put("agreementHandle", agreementHandle);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["pucSponsorPublicKey"] = tars::JsonOutput::writeJson(pucSponsorPublicKey);
                            _p->value["pucSponsorTmpPublicKey"] = tars::JsonOutput::writeJson(pucSponsorTmpPublicKey);
                            _p->value["agreementHandle"] = tars::JsonOutput::writeJson(agreementHandle);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(pucSponsorPublicKey, 6);
                            _os.write(pucSponsorTmpPublicKey, 7);
                            _os.write(agreementHandle, 8);
                            _os.swap(_sResponseBuffer);
                        }
                        if (_pSptd_ && _pSptd_->_traceCall)
                        {
                            string _trace_param_;
                            int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _sResponseBuffer.size());
                            if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                            {
                                tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                                _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                                _p_->value["pucSponsorPublicKey"] = tars::JsonOutput::writeJson(pucSponsorPublicKey);
                                _p_->value["pucSponsorTmpPublicKey"] = tars::JsonOutput::writeJson(pucSponsorTmpPublicKey);
                                _p_->value["agreementHandle"] = tars::JsonOutput::writeJson(agreementHandle);
                                _trace_param_ = tars::TC_Json::writeValue(_p_);
                            }
                            else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                            {
                                _trace_param_ = "{\"trace_param_over_max_len\":true}";
                            }
                            TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS), TRACE_ANNOTATION_SS, "", ServerConfig::Application + "." + ServerConfig::ServerName, "generateAgreementDataWithECC", 0, _trace_param_, "");
                        }

                    }
                    else if(_pSptd_ && _pSptd_->_traceCall)
                    {
                        _current->setTrace(_pSptd_->_traceCall, _pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS));
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 9:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    Mitsurugi::PhSessionHandle sessionHandle;
                    tars::UInt32 uiAlgID;
                    tars::UInt32 uiKeyBits;
                    Mitsurugi::Tars_ECCrefPublicKey pucPublicKey;
                    Mitsurugi::Tars_ECCrefPrivateKey pucPrivateKey;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("sessionHandle", sessionHandle);
                        _tarsAttr_.get("uiAlgID", uiAlgID);
                        _tarsAttr_.get("uiKeyBits", uiKeyBits);
                        _tarsAttr_.getByDefault("pucPublicKey", pucPublicKey, pucPublicKey);
                        _tarsAttr_.getByDefault("pucPrivateKey", pucPrivateKey, pucPrivateKey);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(sessionHandle, _jsonPtr->value["sessionHandle"], true);
                        tars::JsonInput::readJson(uiAlgID, _jsonPtr->value["uiAlgID"], true);
                        tars::JsonInput::readJson(uiKeyBits, _jsonPtr->value["uiKeyBits"], true);
                        tars::JsonInput::readJson(pucPublicKey, _jsonPtr->value["pucPublicKey"], false);
                        tars::JsonInput::readJson(pucPrivateKey, _jsonPtr->value["pucPrivateKey"], false);
                    }
                    else
                    {
                        _is.read(sessionHandle, 1, true);
                        _is.read(uiAlgID, 2, true);
                        _is.read(uiKeyBits, 3, true);
                        _is.read(pucPublicKey, 4, false);
                        _is.read(pucPrivateKey, 5, false);
                    }
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                            _p_->value["uiAlgID"] = tars::JsonOutput::writeJson(uiAlgID);
                            _p_->value["uiKeyBits"] = tars::JsonOutput::writeJson(uiKeyBits);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SR), TRACE_ANNOTATION_SR, "", ServerConfig::Application + "." + ServerConfig::ServerName, "generateKeyPair_ECC", 0, _trace_param_, "");
                    }

                    tars::Int32 _ret = generateKeyPair_ECC(std::move(sessionHandle),uiAlgID,uiKeyBits,pucPublicKey,pucPrivateKey, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("pucPublicKey", pucPublicKey);
                            _tarsAttr_.put("pucPrivateKey", pucPrivateKey);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["pucPublicKey"] = tars::JsonOutput::writeJson(pucPublicKey);
                            _p->value["pucPrivateKey"] = tars::JsonOutput::writeJson(pucPrivateKey);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(pucPublicKey, 4);
                            _os.write(pucPrivateKey, 5);
                            _os.swap(_sResponseBuffer);
                        }
                        if (_pSptd_ && _pSptd_->_traceCall)
                        {
                            string _trace_param_;
                            int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _sResponseBuffer.size());
                            if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                            {
                                tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                                _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                                _p_->value["pucPublicKey"] = tars::JsonOutput::writeJson(pucPublicKey);
                                _p_->value["pucPrivateKey"] = tars::JsonOutput::writeJson(pucPrivateKey);
                                _trace_param_ = tars::TC_Json::writeValue(_p_);
                            }
                            else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                            {
                                _trace_param_ = "{\"trace_param_over_max_len\":true}";
                            }
                            TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS), TRACE_ANNOTATION_SS, "", ServerConfig::Application + "." + ServerConfig::ServerName, "generateKeyPair_ECC", 0, _trace_param_, "");
                        }

                    }
                    else if(_pSptd_ && _pSptd_->_traceCall)
                    {
                        _current->setTrace(_pSptd_->_traceCall, _pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS));
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 10:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    Mitsurugi::PhSessionHandle sessionHandle;
                    tars::UInt32 uiKeyBits;
                    Mitsurugi::Tars_RSArefPublicKey pucPublicKey;
                    Mitsurugi::Tars_RSArefPrivateKey pucPrivateKey;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("sessionHandle", sessionHandle);
                        _tarsAttr_.get("uiKeyBits", uiKeyBits);
                        _tarsAttr_.getByDefault("pucPublicKey", pucPublicKey, pucPublicKey);
                        _tarsAttr_.getByDefault("pucPrivateKey", pucPrivateKey, pucPrivateKey);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(sessionHandle, _jsonPtr->value["sessionHandle"], true);
                        tars::JsonInput::readJson(uiKeyBits, _jsonPtr->value["uiKeyBits"], true);
                        tars::JsonInput::readJson(pucPublicKey, _jsonPtr->value["pucPublicKey"], false);
                        tars::JsonInput::readJson(pucPrivateKey, _jsonPtr->value["pucPrivateKey"], false);
                    }
                    else
                    {
                        _is.read(sessionHandle, 1, true);
                        _is.read(uiKeyBits, 2, true);
                        _is.read(pucPublicKey, 3, false);
                        _is.read(pucPrivateKey, 4, false);
                    }
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                            _p_->value["uiKeyBits"] = tars::JsonOutput::writeJson(uiKeyBits);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SR), TRACE_ANNOTATION_SR, "", ServerConfig::Application + "." + ServerConfig::ServerName, "generateKeyPair_RSA", 0, _trace_param_, "");
                    }

                    tars::Int32 _ret = generateKeyPair_RSA(std::move(sessionHandle),uiKeyBits,pucPublicKey,pucPrivateKey, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("pucPublicKey", pucPublicKey);
                            _tarsAttr_.put("pucPrivateKey", pucPrivateKey);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["pucPublicKey"] = tars::JsonOutput::writeJson(pucPublicKey);
                            _p->value["pucPrivateKey"] = tars::JsonOutput::writeJson(pucPrivateKey);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(pucPublicKey, 3);
                            _os.write(pucPrivateKey, 4);
                            _os.swap(_sResponseBuffer);
                        }
                        if (_pSptd_ && _pSptd_->_traceCall)
                        {
                            string _trace_param_;
                            int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _sResponseBuffer.size());
                            if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                            {
                                tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                                _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                                _p_->value["pucPublicKey"] = tars::JsonOutput::writeJson(pucPublicKey);
                                _p_->value["pucPrivateKey"] = tars::JsonOutput::writeJson(pucPrivateKey);
                                _trace_param_ = tars::TC_Json::writeValue(_p_);
                            }
                            else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                            {
                                _trace_param_ = "{\"trace_param_over_max_len\":true}";
                            }
                            TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS), TRACE_ANNOTATION_SS, "", ServerConfig::Application + "." + ServerConfig::ServerName, "generateKeyPair_RSA", 0, _trace_param_, "");
                        }

                    }
                    else if(_pSptd_ && _pSptd_->_traceCall)
                    {
                        _current->setTrace(_pSptd_->_traceCall, _pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS));
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 11:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    Mitsurugi::PhSessionHandle sessionHandle;
                    vector<tars::UInt8> pucResponseID;
                    tars::UInt32 uiResponseIDLength;
                    Mitsurugi::Tars_ECCrefPublicKey pucResponsePublicKey;
                    Mitsurugi::Tars_ECCrefPublicKey pucResponseTmpPublicKey;
                    Mitsurugi::PhAgreementHandle agreementHandle;
                    Mitsurugi::PhKeyHandle keyHandle;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("sessionHandle", sessionHandle);
                        _tarsAttr_.get("pucResponseID", pucResponseID);
                        _tarsAttr_.get("uiResponseIDLength", uiResponseIDLength);
                        _tarsAttr_.get("pucResponsePublicKey", pucResponsePublicKey);
                        _tarsAttr_.get("pucResponseTmpPublicKey", pucResponseTmpPublicKey);
                        _tarsAttr_.get("agreementHandle", agreementHandle);
                        _tarsAttr_.getByDefault("keyHandle", keyHandle, keyHandle);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(sessionHandle, _jsonPtr->value["sessionHandle"], true);
                        tars::JsonInput::readJson(pucResponseID, _jsonPtr->value["pucResponseID"], true);
                        tars::JsonInput::readJson(uiResponseIDLength, _jsonPtr->value["uiResponseIDLength"], true);
                        tars::JsonInput::readJson(pucResponsePublicKey, _jsonPtr->value["pucResponsePublicKey"], true);
                        tars::JsonInput::readJson(pucResponseTmpPublicKey, _jsonPtr->value["pucResponseTmpPublicKey"], true);
                        tars::JsonInput::readJson(agreementHandle, _jsonPtr->value["agreementHandle"], true);
                        tars::JsonInput::readJson(keyHandle, _jsonPtr->value["keyHandle"], false);
                    }
                    else
                    {
                        _is.read(sessionHandle, 1, true);
                        _is.read(pucResponseID, 2, true);
                        _is.read(uiResponseIDLength, 3, true);
                        _is.read(pucResponsePublicKey, 4, true);
                        _is.read(pucResponseTmpPublicKey, 5, true);
                        _is.read(agreementHandle, 6, true);
                        _is.read(keyHandle, 7, false);
                    }
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                            _p_->value["pucResponseID"] = tars::JsonOutput::writeJson(pucResponseID);
                            _p_->value["uiResponseIDLength"] = tars::JsonOutput::writeJson(uiResponseIDLength);
                            _p_->value["pucResponsePublicKey"] = tars::JsonOutput::writeJson(pucResponsePublicKey);
                            _p_->value["pucResponseTmpPublicKey"] = tars::JsonOutput::writeJson(pucResponseTmpPublicKey);
                            _p_->value["agreementHandle"] = tars::JsonOutput::writeJson(agreementHandle);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SR), TRACE_ANNOTATION_SR, "", ServerConfig::Application + "." + ServerConfig::ServerName, "generateKeyWithECC", 0, _trace_param_, "");
                    }

                    tars::Int32 _ret = generateKeyWithECC(std::move(sessionHandle),std::move(pucResponseID),uiResponseIDLength,std::move(pucResponsePublicKey),std::move(pucResponseTmpPublicKey),std::move(agreementHandle),keyHandle, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("keyHandle", keyHandle);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(keyHandle, 7);
                            _os.swap(_sResponseBuffer);
                        }
                        if (_pSptd_ && _pSptd_->_traceCall)
                        {
                            string _trace_param_;
                            int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _sResponseBuffer.size());
                            if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                            {
                                tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                                _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                                _p_->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                                _trace_param_ = tars::TC_Json::writeValue(_p_);
                            }
                            else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                            {
                                _trace_param_ = "{\"trace_param_over_max_len\":true}";
                            }
                            TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS), TRACE_ANNOTATION_SS, "", ServerConfig::Application + "." + ServerConfig::ServerName, "generateKeyWithECC", 0, _trace_param_, "");
                        }

                    }
                    else if(_pSptd_ && _pSptd_->_traceCall)
                    {
                        _current->setTrace(_pSptd_->_traceCall, _pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS));
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 12:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    Mitsurugi::PhSessionHandle sessionHandle;
                    tars::UInt32 uiKeyBits;
                    tars::UInt32 uiAlgID;
                    Mitsurugi::Tars_ECCrefPublicKey pucPublicKey;
                    Mitsurugi::Tars_ECCCipher pucKey;
                    Mitsurugi::PhKeyHandle keyHandle;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("sessionHandle", sessionHandle);
                        _tarsAttr_.get("uiKeyBits", uiKeyBits);
                        _tarsAttr_.get("uiAlgID", uiAlgID);
                        _tarsAttr_.get("pucPublicKey", pucPublicKey);
                        _tarsAttr_.getByDefault("pucKey", pucKey, pucKey);
                        _tarsAttr_.getByDefault("keyHandle", keyHandle, keyHandle);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(sessionHandle, _jsonPtr->value["sessionHandle"], true);
                        tars::JsonInput::readJson(uiKeyBits, _jsonPtr->value["uiKeyBits"], true);
                        tars::JsonInput::readJson(uiAlgID, _jsonPtr->value["uiAlgID"], true);
                        tars::JsonInput::readJson(pucPublicKey, _jsonPtr->value["pucPublicKey"], true);
                        tars::JsonInput::readJson(pucKey, _jsonPtr->value["pucKey"], false);
                        tars::JsonInput::readJson(keyHandle, _jsonPtr->value["keyHandle"], false);
                    }
                    else
                    {
                        _is.read(sessionHandle, 1, true);
                        _is.read(uiKeyBits, 2, true);
                        _is.read(uiAlgID, 3, true);
                        _is.read(pucPublicKey, 4, true);
                        _is.read(pucKey, 5, false);
                        _is.read(keyHandle, 6, false);
                    }
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                            _p_->value["uiKeyBits"] = tars::JsonOutput::writeJson(uiKeyBits);
                            _p_->value["uiAlgID"] = tars::JsonOutput::writeJson(uiAlgID);
                            _p_->value["pucPublicKey"] = tars::JsonOutput::writeJson(pucPublicKey);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SR), TRACE_ANNOTATION_SR, "", ServerConfig::Application + "." + ServerConfig::ServerName, "generateKeyWithEPK_ECC", 0, _trace_param_, "");
                    }

                    tars::Int32 _ret = generateKeyWithEPK_ECC(std::move(sessionHandle),uiKeyBits,uiAlgID,std::move(pucPublicKey),pucKey,keyHandle, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("pucKey", pucKey);
                            _tarsAttr_.put("keyHandle", keyHandle);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["pucKey"] = tars::JsonOutput::writeJson(pucKey);
                            _p->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(pucKey, 5);
                            _os.write(keyHandle, 6);
                            _os.swap(_sResponseBuffer);
                        }
                        if (_pSptd_ && _pSptd_->_traceCall)
                        {
                            string _trace_param_;
                            int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _sResponseBuffer.size());
                            if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                            {
                                tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                                _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                                _p_->value["pucKey"] = tars::JsonOutput::writeJson(pucKey);
                                _p_->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                                _trace_param_ = tars::TC_Json::writeValue(_p_);
                            }
                            else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                            {
                                _trace_param_ = "{\"trace_param_over_max_len\":true}";
                            }
                            TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS), TRACE_ANNOTATION_SS, "", ServerConfig::Application + "." + ServerConfig::ServerName, "generateKeyWithEPK_ECC", 0, _trace_param_, "");
                        }

                    }
                    else if(_pSptd_ && _pSptd_->_traceCall)
                    {
                        _current->setTrace(_pSptd_->_traceCall, _pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS));
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 13:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    Mitsurugi::PhSessionHandle sessionHandle;
                    tars::UInt32 uiKeyBits;
                    Mitsurugi::Tars_RSArefPublicKey pucPublicKey;
                    vector<tars::UInt8> pucKey;
                    tars::UInt32 puiKeyLength;
                    Mitsurugi::PhKeyHandle keyHandle;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("sessionHandle", sessionHandle);
                        _tarsAttr_.get("uiKeyBits", uiKeyBits);
                        _tarsAttr_.get("pucPublicKey", pucPublicKey);
                        _tarsAttr_.getByDefault("pucKey", pucKey, pucKey);
                        _tarsAttr_.getByDefault("puiKeyLength", puiKeyLength, puiKeyLength);
                        _tarsAttr_.getByDefault("keyHandle", keyHandle, keyHandle);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(sessionHandle, _jsonPtr->value["sessionHandle"], true);
                        tars::JsonInput::readJson(uiKeyBits, _jsonPtr->value["uiKeyBits"], true);
                        tars::JsonInput::readJson(pucPublicKey, _jsonPtr->value["pucPublicKey"], true);
                        tars::JsonInput::readJson(pucKey, _jsonPtr->value["pucKey"], false);
                        tars::JsonInput::readJson(puiKeyLength, _jsonPtr->value["puiKeyLength"], false);
                        tars::JsonInput::readJson(keyHandle, _jsonPtr->value["keyHandle"], false);
                    }
                    else
                    {
                        _is.read(sessionHandle, 1, true);
                        _is.read(uiKeyBits, 2, true);
                        _is.read(pucPublicKey, 3, true);
                        _is.read(pucKey, 4, false);
                        _is.read(puiKeyLength, 5, false);
                        _is.read(keyHandle, 6, false);
                    }
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                            _p_->value["uiKeyBits"] = tars::JsonOutput::writeJson(uiKeyBits);
                            _p_->value["pucPublicKey"] = tars::JsonOutput::writeJson(pucPublicKey);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SR), TRACE_ANNOTATION_SR, "", ServerConfig::Application + "." + ServerConfig::ServerName, "generateKeyWithEPK_RSA", 0, _trace_param_, "");
                    }

                    tars::Int32 _ret = generateKeyWithEPK_RSA(std::move(sessionHandle),uiKeyBits,std::move(pucPublicKey),pucKey,puiKeyLength,keyHandle, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("pucKey", pucKey);
                            _tarsAttr_.put("puiKeyLength", puiKeyLength);
                            _tarsAttr_.put("keyHandle", keyHandle);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["pucKey"] = tars::JsonOutput::writeJson(pucKey);
                            _p->value["puiKeyLength"] = tars::JsonOutput::writeJson(puiKeyLength);
                            _p->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(pucKey, 4);
                            _os.write(puiKeyLength, 5);
                            _os.write(keyHandle, 6);
                            _os.swap(_sResponseBuffer);
                        }
                        if (_pSptd_ && _pSptd_->_traceCall)
                        {
                            string _trace_param_;
                            int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _sResponseBuffer.size());
                            if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                            {
                                tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                                _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                                _p_->value["pucKey"] = tars::JsonOutput::writeJson(pucKey);
                                _p_->value["puiKeyLength"] = tars::JsonOutput::writeJson(puiKeyLength);
                                _p_->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                                _trace_param_ = tars::TC_Json::writeValue(_p_);
                            }
                            else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                            {
                                _trace_param_ = "{\"trace_param_over_max_len\":true}";
                            }
                            TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS), TRACE_ANNOTATION_SS, "", ServerConfig::Application + "." + ServerConfig::ServerName, "generateKeyWithEPK_RSA", 0, _trace_param_, "");
                        }

                    }
                    else if(_pSptd_ && _pSptd_->_traceCall)
                    {
                        _current->setTrace(_pSptd_->_traceCall, _pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS));
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 14:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    Mitsurugi::PhSessionHandle sessionHandle;
                    tars::UInt32 uiIPKIndex;
                    tars::UInt32 uiKeyBits;
                    Mitsurugi::Tars_ECCCipher pucKey;
                    Mitsurugi::PhKeyHandle keyHandle;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("sessionHandle", sessionHandle);
                        _tarsAttr_.get("uiIPKIndex", uiIPKIndex);
                        _tarsAttr_.get("uiKeyBits", uiKeyBits);
                        _tarsAttr_.getByDefault("pucKey", pucKey, pucKey);
                        _tarsAttr_.getByDefault("keyHandle", keyHandle, keyHandle);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(sessionHandle, _jsonPtr->value["sessionHandle"], true);
                        tars::JsonInput::readJson(uiIPKIndex, _jsonPtr->value["uiIPKIndex"], true);
                        tars::JsonInput::readJson(uiKeyBits, _jsonPtr->value["uiKeyBits"], true);
                        tars::JsonInput::readJson(pucKey, _jsonPtr->value["pucKey"], false);
                        tars::JsonInput::readJson(keyHandle, _jsonPtr->value["keyHandle"], false);
                    }
                    else
                    {
                        _is.read(sessionHandle, 1, true);
                        _is.read(uiIPKIndex, 2, true);
                        _is.read(uiKeyBits, 3, true);
                        _is.read(pucKey, 4, false);
                        _is.read(keyHandle, 5, false);
                    }
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                            _p_->value["uiIPKIndex"] = tars::JsonOutput::writeJson(uiIPKIndex);
                            _p_->value["uiKeyBits"] = tars::JsonOutput::writeJson(uiKeyBits);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SR), TRACE_ANNOTATION_SR, "", ServerConfig::Application + "." + ServerConfig::ServerName, "generateKeyWithIPK_ECC", 0, _trace_param_, "");
                    }

                    tars::Int32 _ret = generateKeyWithIPK_ECC(std::move(sessionHandle),uiIPKIndex,uiKeyBits,pucKey,keyHandle, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("pucKey", pucKey);
                            _tarsAttr_.put("keyHandle", keyHandle);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["pucKey"] = tars::JsonOutput::writeJson(pucKey);
                            _p->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(pucKey, 4);
                            _os.write(keyHandle, 5);
                            _os.swap(_sResponseBuffer);
                        }
                        if (_pSptd_ && _pSptd_->_traceCall)
                        {
                            string _trace_param_;
                            int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _sResponseBuffer.size());
                            if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                            {
                                tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                                _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                                _p_->value["pucKey"] = tars::JsonOutput::writeJson(pucKey);
                                _p_->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                                _trace_param_ = tars::TC_Json::writeValue(_p_);
                            }
                            else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                            {
                                _trace_param_ = "{\"trace_param_over_max_len\":true}";
                            }
                            TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS), TRACE_ANNOTATION_SS, "", ServerConfig::Application + "." + ServerConfig::ServerName, "generateKeyWithIPK_ECC", 0, _trace_param_, "");
                        }

                    }
                    else if(_pSptd_ && _pSptd_->_traceCall)
                    {
                        _current->setTrace(_pSptd_->_traceCall, _pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS));
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 15:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    Mitsurugi::PhSessionHandle sessionHandle;
                    tars::UInt32 uiPKIIndex;
                    tars::UInt32 uiKeyBits;
                    vector<tars::UInt8> pucKey;
                    tars::UInt32 puiKeyLength;
                    Mitsurugi::PhKeyHandle keyHandle;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("sessionHandle", sessionHandle);
                        _tarsAttr_.get("uiPKIIndex", uiPKIIndex);
                        _tarsAttr_.get("uiKeyBits", uiKeyBits);
                        _tarsAttr_.getByDefault("pucKey", pucKey, pucKey);
                        _tarsAttr_.getByDefault("puiKeyLength", puiKeyLength, puiKeyLength);
                        _tarsAttr_.getByDefault("keyHandle", keyHandle, keyHandle);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(sessionHandle, _jsonPtr->value["sessionHandle"], true);
                        tars::JsonInput::readJson(uiPKIIndex, _jsonPtr->value["uiPKIIndex"], true);
                        tars::JsonInput::readJson(uiKeyBits, _jsonPtr->value["uiKeyBits"], true);
                        tars::JsonInput::readJson(pucKey, _jsonPtr->value["pucKey"], false);
                        tars::JsonInput::readJson(puiKeyLength, _jsonPtr->value["puiKeyLength"], false);
                        tars::JsonInput::readJson(keyHandle, _jsonPtr->value["keyHandle"], false);
                    }
                    else
                    {
                        _is.read(sessionHandle, 1, true);
                        _is.read(uiPKIIndex, 2, true);
                        _is.read(uiKeyBits, 3, true);
                        _is.read(pucKey, 4, false);
                        _is.read(puiKeyLength, 5, false);
                        _is.read(keyHandle, 6, false);
                    }
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                            _p_->value["uiPKIIndex"] = tars::JsonOutput::writeJson(uiPKIIndex);
                            _p_->value["uiKeyBits"] = tars::JsonOutput::writeJson(uiKeyBits);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SR), TRACE_ANNOTATION_SR, "", ServerConfig::Application + "." + ServerConfig::ServerName, "generateKeyWithIPK_RSA", 0, _trace_param_, "");
                    }

                    tars::Int32 _ret = generateKeyWithIPK_RSA(std::move(sessionHandle),uiPKIIndex,uiKeyBits,pucKey,puiKeyLength,keyHandle, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("pucKey", pucKey);
                            _tarsAttr_.put("puiKeyLength", puiKeyLength);
                            _tarsAttr_.put("keyHandle", keyHandle);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["pucKey"] = tars::JsonOutput::writeJson(pucKey);
                            _p->value["puiKeyLength"] = tars::JsonOutput::writeJson(puiKeyLength);
                            _p->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(pucKey, 4);
                            _os.write(puiKeyLength, 5);
                            _os.write(keyHandle, 6);
                            _os.swap(_sResponseBuffer);
                        }
                        if (_pSptd_ && _pSptd_->_traceCall)
                        {
                            string _trace_param_;
                            int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _sResponseBuffer.size());
                            if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                            {
                                tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                                _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                                _p_->value["pucKey"] = tars::JsonOutput::writeJson(pucKey);
                                _p_->value["puiKeyLength"] = tars::JsonOutput::writeJson(puiKeyLength);
                                _p_->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                                _trace_param_ = tars::TC_Json::writeValue(_p_);
                            }
                            else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                            {
                                _trace_param_ = "{\"trace_param_over_max_len\":true}";
                            }
                            TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS), TRACE_ANNOTATION_SS, "", ServerConfig::Application + "." + ServerConfig::ServerName, "generateKeyWithIPK_RSA", 0, _trace_param_, "");
                        }

                    }
                    else if(_pSptd_ && _pSptd_->_traceCall)
                    {
                        _current->setTrace(_pSptd_->_traceCall, _pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS));
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 16:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    Mitsurugi::PhSessionHandle sessionHandle;
                    tars::UInt32 uiKeyBits;
                    tars::UInt32 uiAlgID;
                    tars::UInt32 uiKEKIndex;
                    vector<tars::UInt8> pucKey;
                    tars::UInt32 puiKeyLength;
                    Mitsurugi::PhKeyHandle keyHandle;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("sessionHandle", sessionHandle);
                        _tarsAttr_.get("uiKeyBits", uiKeyBits);
                        _tarsAttr_.get("uiAlgID", uiAlgID);
                        _tarsAttr_.get("uiKEKIndex", uiKEKIndex);
                        _tarsAttr_.getByDefault("pucKey", pucKey, pucKey);
                        _tarsAttr_.getByDefault("puiKeyLength", puiKeyLength, puiKeyLength);
                        _tarsAttr_.getByDefault("keyHandle", keyHandle, keyHandle);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(sessionHandle, _jsonPtr->value["sessionHandle"], true);
                        tars::JsonInput::readJson(uiKeyBits, _jsonPtr->value["uiKeyBits"], true);
                        tars::JsonInput::readJson(uiAlgID, _jsonPtr->value["uiAlgID"], true);
                        tars::JsonInput::readJson(uiKEKIndex, _jsonPtr->value["uiKEKIndex"], true);
                        tars::JsonInput::readJson(pucKey, _jsonPtr->value["pucKey"], false);
                        tars::JsonInput::readJson(puiKeyLength, _jsonPtr->value["puiKeyLength"], false);
                        tars::JsonInput::readJson(keyHandle, _jsonPtr->value["keyHandle"], false);
                    }
                    else
                    {
                        _is.read(sessionHandle, 1, true);
                        _is.read(uiKeyBits, 2, true);
                        _is.read(uiAlgID, 3, true);
                        _is.read(uiKEKIndex, 4, true);
                        _is.read(pucKey, 5, false);
                        _is.read(puiKeyLength, 6, false);
                        _is.read(keyHandle, 7, false);
                    }
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                            _p_->value["uiKeyBits"] = tars::JsonOutput::writeJson(uiKeyBits);
                            _p_->value["uiAlgID"] = tars::JsonOutput::writeJson(uiAlgID);
                            _p_->value["uiKEKIndex"] = tars::JsonOutput::writeJson(uiKEKIndex);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SR), TRACE_ANNOTATION_SR, "", ServerConfig::Application + "." + ServerConfig::ServerName, "generateKeyWithKEK", 0, _trace_param_, "");
                    }

                    tars::Int32 _ret = generateKeyWithKEK(std::move(sessionHandle),uiKeyBits,uiAlgID,uiKEKIndex,pucKey,puiKeyLength,keyHandle, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("pucKey", pucKey);
                            _tarsAttr_.put("puiKeyLength", puiKeyLength);
                            _tarsAttr_.put("keyHandle", keyHandle);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["pucKey"] = tars::JsonOutput::writeJson(pucKey);
                            _p->value["puiKeyLength"] = tars::JsonOutput::writeJson(puiKeyLength);
                            _p->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(pucKey, 5);
                            _os.write(puiKeyLength, 6);
                            _os.write(keyHandle, 7);
                            _os.swap(_sResponseBuffer);
                        }
                        if (_pSptd_ && _pSptd_->_traceCall)
                        {
                            string _trace_param_;
                            int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _sResponseBuffer.size());
                            if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                            {
                                tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                                _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                                _p_->value["pucKey"] = tars::JsonOutput::writeJson(pucKey);
                                _p_->value["puiKeyLength"] = tars::JsonOutput::writeJson(puiKeyLength);
                                _p_->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                                _trace_param_ = tars::TC_Json::writeValue(_p_);
                            }
                            else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                            {
                                _trace_param_ = "{\"trace_param_over_max_len\":true}";
                            }
                            TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS), TRACE_ANNOTATION_SS, "", ServerConfig::Application + "." + ServerConfig::ServerName, "generateKeyWithKEK", 0, _trace_param_, "");
                        }

                    }
                    else if(_pSptd_ && _pSptd_->_traceCall)
                    {
                        _current->setTrace(_pSptd_->_traceCall, _pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS));
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 17:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    Mitsurugi::PhSessionHandle sessionHandle;
                    vector<tars::UInt8> pucKey;
                    tars::UInt32 uiKeyLength;
                    Mitsurugi::PhKeyHandle keyHandle;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("sessionHandle", sessionHandle);
                        _tarsAttr_.get("pucKey", pucKey);
                        _tarsAttr_.get("uiKeyLength", uiKeyLength);
                        _tarsAttr_.getByDefault("keyHandle", keyHandle, keyHandle);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(sessionHandle, _jsonPtr->value["sessionHandle"], true);
                        tars::JsonInput::readJson(pucKey, _jsonPtr->value["pucKey"], true);
                        tars::JsonInput::readJson(uiKeyLength, _jsonPtr->value["uiKeyLength"], true);
                        tars::JsonInput::readJson(keyHandle, _jsonPtr->value["keyHandle"], false);
                    }
                    else
                    {
                        _is.read(sessionHandle, 1, true);
                        _is.read(pucKey, 2, true);
                        _is.read(uiKeyLength, 3, true);
                        _is.read(keyHandle, 4, false);
                    }
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                            _p_->value["pucKey"] = tars::JsonOutput::writeJson(pucKey);
                            _p_->value["uiKeyLength"] = tars::JsonOutput::writeJson(uiKeyLength);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SR), TRACE_ANNOTATION_SR, "", ServerConfig::Application + "." + ServerConfig::ServerName, "importKey", 0, _trace_param_, "");
                    }

                    tars::Int32 _ret = importKey(std::move(sessionHandle),std::move(pucKey),uiKeyLength,keyHandle, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("keyHandle", keyHandle);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(keyHandle, 4);
                            _os.swap(_sResponseBuffer);
                        }
                        if (_pSptd_ && _pSptd_->_traceCall)
                        {
                            string _trace_param_;
                            int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _sResponseBuffer.size());
                            if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                            {
                                tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                                _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                                _p_->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                                _trace_param_ = tars::TC_Json::writeValue(_p_);
                            }
                            else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                            {
                                _trace_param_ = "{\"trace_param_over_max_len\":true}";
                            }
                            TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS), TRACE_ANNOTATION_SS, "", ServerConfig::Application + "." + ServerConfig::ServerName, "importKey", 0, _trace_param_, "");
                        }

                    }
                    else if(_pSptd_ && _pSptd_->_traceCall)
                    {
                        _current->setTrace(_pSptd_->_traceCall, _pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS));
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 18:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    Mitsurugi::PhSessionHandle sessionHandle;
                    tars::UInt32 uiISKIndex;
                    Mitsurugi::Tars_ECCCipher pucKey;
                    Mitsurugi::PhKeyHandle keyHandle;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("sessionHandle", sessionHandle);
                        _tarsAttr_.get("uiISKIndex", uiISKIndex);
                        _tarsAttr_.get("pucKey", pucKey);
                        _tarsAttr_.getByDefault("keyHandle", keyHandle, keyHandle);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(sessionHandle, _jsonPtr->value["sessionHandle"], true);
                        tars::JsonInput::readJson(uiISKIndex, _jsonPtr->value["uiISKIndex"], true);
                        tars::JsonInput::readJson(pucKey, _jsonPtr->value["pucKey"], true);
                        tars::JsonInput::readJson(keyHandle, _jsonPtr->value["keyHandle"], false);
                    }
                    else
                    {
                        _is.read(sessionHandle, 1, true);
                        _is.read(uiISKIndex, 2, true);
                        _is.read(pucKey, 3, true);
                        _is.read(keyHandle, 4, false);
                    }
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                            _p_->value["uiISKIndex"] = tars::JsonOutput::writeJson(uiISKIndex);
                            _p_->value["pucKey"] = tars::JsonOutput::writeJson(pucKey);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SR), TRACE_ANNOTATION_SR, "", ServerConfig::Application + "." + ServerConfig::ServerName, "importKeyWithISK_ECC", 0, _trace_param_, "");
                    }

                    tars::Int32 _ret = importKeyWithISK_ECC(std::move(sessionHandle),uiISKIndex,std::move(pucKey),keyHandle, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("keyHandle", keyHandle);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(keyHandle, 4);
                            _os.swap(_sResponseBuffer);
                        }
                        if (_pSptd_ && _pSptd_->_traceCall)
                        {
                            string _trace_param_;
                            int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _sResponseBuffer.size());
                            if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                            {
                                tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                                _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                                _p_->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                                _trace_param_ = tars::TC_Json::writeValue(_p_);
                            }
                            else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                            {
                                _trace_param_ = "{\"trace_param_over_max_len\":true}";
                            }
                            TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS), TRACE_ANNOTATION_SS, "", ServerConfig::Application + "." + ServerConfig::ServerName, "importKeyWithISK_ECC", 0, _trace_param_, "");
                        }

                    }
                    else if(_pSptd_ && _pSptd_->_traceCall)
                    {
                        _current->setTrace(_pSptd_->_traceCall, _pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS));
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 19:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    Mitsurugi::PhSessionHandle sessionHandle;
                    tars::UInt32 uiISKIndex;
                    vector<tars::UInt8> pucKey;
                    tars::UInt32 puiKeyLength;
                    Mitsurugi::PhKeyHandle keyHandle;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("sessionHandle", sessionHandle);
                        _tarsAttr_.get("uiISKIndex", uiISKIndex);
                        _tarsAttr_.get("pucKey", pucKey);
                        _tarsAttr_.get("puiKeyLength", puiKeyLength);
                        _tarsAttr_.getByDefault("keyHandle", keyHandle, keyHandle);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(sessionHandle, _jsonPtr->value["sessionHandle"], true);
                        tars::JsonInput::readJson(uiISKIndex, _jsonPtr->value["uiISKIndex"], true);
                        tars::JsonInput::readJson(pucKey, _jsonPtr->value["pucKey"], true);
                        tars::JsonInput::readJson(puiKeyLength, _jsonPtr->value["puiKeyLength"], true);
                        tars::JsonInput::readJson(keyHandle, _jsonPtr->value["keyHandle"], false);
                    }
                    else
                    {
                        _is.read(sessionHandle, 1, true);
                        _is.read(uiISKIndex, 2, true);
                        _is.read(pucKey, 3, true);
                        _is.read(puiKeyLength, 4, true);
                        _is.read(keyHandle, 5, false);
                    }
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                            _p_->value["uiISKIndex"] = tars::JsonOutput::writeJson(uiISKIndex);
                            _p_->value["pucKey"] = tars::JsonOutput::writeJson(pucKey);
                            _p_->value["puiKeyLength"] = tars::JsonOutput::writeJson(puiKeyLength);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SR), TRACE_ANNOTATION_SR, "", ServerConfig::Application + "." + ServerConfig::ServerName, "importKeyWithISK_RSA", 0, _trace_param_, "");
                    }

                    tars::Int32 _ret = importKeyWithISK_RSA(std::move(sessionHandle),uiISKIndex,std::move(pucKey),puiKeyLength,keyHandle, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("keyHandle", keyHandle);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(keyHandle, 5);
                            _os.swap(_sResponseBuffer);
                        }
                        if (_pSptd_ && _pSptd_->_traceCall)
                        {
                            string _trace_param_;
                            int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _sResponseBuffer.size());
                            if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                            {
                                tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                                _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                                _p_->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                                _trace_param_ = tars::TC_Json::writeValue(_p_);
                            }
                            else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                            {
                                _trace_param_ = "{\"trace_param_over_max_len\":true}";
                            }
                            TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS), TRACE_ANNOTATION_SS, "", ServerConfig::Application + "." + ServerConfig::ServerName, "importKeyWithISK_RSA", 0, _trace_param_, "");
                        }

                    }
                    else if(_pSptd_ && _pSptd_->_traceCall)
                    {
                        _current->setTrace(_pSptd_->_traceCall, _pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS));
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 20:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    Mitsurugi::PhSessionHandle sessionHandle;
                    tars::UInt32 uiAlgID;
                    tars::UInt32 uiKEKIndex;
                    vector<tars::UInt8> pucKey;
                    tars::UInt32 puiKeyLength;
                    Mitsurugi::PhKeyHandle keyHandle;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("sessionHandle", sessionHandle);
                        _tarsAttr_.get("uiAlgID", uiAlgID);
                        _tarsAttr_.get("uiKEKIndex", uiKEKIndex);
                        _tarsAttr_.get("pucKey", pucKey);
                        _tarsAttr_.get("puiKeyLength", puiKeyLength);
                        _tarsAttr_.getByDefault("keyHandle", keyHandle, keyHandle);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(sessionHandle, _jsonPtr->value["sessionHandle"], true);
                        tars::JsonInput::readJson(uiAlgID, _jsonPtr->value["uiAlgID"], true);
                        tars::JsonInput::readJson(uiKEKIndex, _jsonPtr->value["uiKEKIndex"], true);
                        tars::JsonInput::readJson(pucKey, _jsonPtr->value["pucKey"], true);
                        tars::JsonInput::readJson(puiKeyLength, _jsonPtr->value["puiKeyLength"], true);
                        tars::JsonInput::readJson(keyHandle, _jsonPtr->value["keyHandle"], false);
                    }
                    else
                    {
                        _is.read(sessionHandle, 1, true);
                        _is.read(uiAlgID, 2, true);
                        _is.read(uiKEKIndex, 3, true);
                        _is.read(pucKey, 4, true);
                        _is.read(puiKeyLength, 5, true);
                        _is.read(keyHandle, 6, false);
                    }
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value["sessionHandle"] = tars::JsonOutput::writeJson(sessionHandle);
                            _p_->value["uiAlgID"] = tars::JsonOutput::writeJson(uiAlgID);
                            _p_->value["uiKEKIndex"] = tars::JsonOutput::writeJson(uiKEKIndex);
                            _p_->value["pucKey"] = tars::JsonOutput::writeJson(pucKey);
                            _p_->value["puiKeyLength"] = tars::JsonOutput::writeJson(puiKeyLength);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SR), TRACE_ANNOTATION_SR, "", ServerConfig::Application + "." + ServerConfig::ServerName, "importKeyWithKEK", 0, _trace_param_, "");
                    }

                    tars::Int32 _ret = importKeyWithKEK(std::move(sessionHandle),uiAlgID,uiKEKIndex,std::move(pucKey),puiKeyLength,keyHandle, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("keyHandle", keyHandle);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(keyHandle, 6);
                            _os.swap(_sResponseBuffer);
                        }
                        if (_pSptd_ && _pSptd_->_traceCall)
                        {
                            string _trace_param_;
                            int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _sResponseBuffer.size());
                            if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                            {
                                tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                                _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                                _p_->value["keyHandle"] = tars::JsonOutput::writeJson(keyHandle);
                                _trace_param_ = tars::TC_Json::writeValue(_p_);
                            }
                            else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                            {
                                _trace_param_ = "{\"trace_param_over_max_len\":true}";
                            }
                            TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS), TRACE_ANNOTATION_SS, "", ServerConfig::Application + "." + ServerConfig::ServerName, "importKeyWithKEK", 0, _trace_param_, "");
                        }

                    }
                    else if(_pSptd_ && _pSptd_->_traceCall)
                    {
                        _current->setTrace(_pSptd_->_traceCall, _pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS));
                    }

                    return tars::TARSSERVERSUCCESS;

                }
            }
            return tars::TARSSERVERNOFUNCERR;
        }
    };


}



#endif
